<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" charset="UTF-8">
    <title>NestedQueryBuilder</title>
    <link href="../../../images/logo-icon.svg" rel="icon" type="image/svg">
    <script>var pathToRoot = "../../../";</script>
    <script>const storage = localStorage.getItem("dokka-dark-mode")
    if (storage == null) {
        const osDarkSchemePreferred = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
        if (osDarkSchemePreferred === true) {
            document.getElementsByTagName("html")[0].classList.add("theme-dark")
        }
    } else {
        const savedDarkMode = JSON.parse(storage)
        if(savedDarkMode === true) {
            document.getElementsByTagName("html")[0].classList.add("theme-dark")
        }
    }
    </script>
<script type="text/javascript" src="../../../scripts/sourceset_dependencies.js" async="async"></script>
<link href="../../../styles/style.css" rel="Stylesheet">
<link href="../../../styles/jetbrains-mono.css" rel="Stylesheet">
<link href="../../../styles/main.css" rel="Stylesheet">
<link href="../../../styles/prism.css" rel="Stylesheet">
<link href="../../../styles/logo-styles.css" rel="Stylesheet">
<script type="text/javascript" src="../../../scripts/clipboard.js" async="async"></script>
<script type="text/javascript" src="../../../scripts/navigation-loader.js" async="async"></script>
<script type="text/javascript" src="../../../scripts/platform-content-handler.js" async="async"></script>
<script type="text/javascript" src="../../../scripts/main.js" defer="defer"></script>
<script type="text/javascript" src="../../../scripts/prism.js" async="async"></script>
<script type="text/javascript" src="../../../scripts/symbol-parameters-wrapper_deferred.js" defer="defer"></script>
<script type="text/javascript" src="../../../dokka-mermaid.js" async="async"></script>
</head>
<body>
<div class="navigation-wrapper" id="navigation-wrapper">
    <div id="leftToggler"><span class="icon-toggler"></span></div>
    <div class="library-name">
            <a href="../../../index.html">
                    <span>Terraware Server</span>
            </a>
    </div>
    <div>
0.1-65f4603-SNAPSHOT    </div>
    <div class="pull-right d-flex">
        <div class="filter-section" id="filter-section">
                <button class="platform-tag platform-selector jvm-like" data-active="" data-filter=":dokkaHtml/main">jvm</button>
        </div>
        <button id="theme-toggle-button"><span id="theme-toggle"></span></button>
        <div id="searchBar"></div>
    </div>
</div>
<div id="container">
    <div id="leftColumn">
        <div id="sideMenu"></div>
    </div>
    <div id="main">
<div class="main-content" data-page-type="classlike" id="content" pageIds="Terraware Server::com.terraformation.backend.search/NestedQueryBuilder///PointingToDeclaration//769193423">
  <div class="breadcrumbs"><a href="../../../index.html">Terraware Server</a><span class="delimiter">/</span><a href="../index.html">com.terraformation.backend.search</a><span class="delimiter">/</span><span class="current">NestedQueryBuilder</span></div>
  <div class="cover ">
    <h1 class="cover"><span>Nested</span><wbr></wbr><span>Query</span><wbr></wbr><span><span>Builder</span></span></h1>
    <div class="platform-hinted " data-platform-hinted="data-platform-hinted"><div class="content sourceset-dependent-content" data-active="" data-togglable=":dokkaHtml/main"><div class="symbol monospace"><span class="token keyword">class </span><a href="index.html">NestedQueryBuilder</a><span class="token punctuation">(</span><span class="parameters "><span class="parameter ">dslContext<span class="token operator">: </span><span data-unresolved-link="org.jooq/DSLContext///PointingToDeclaration/">DSLContext</span><span class="token punctuation">, </span></span><span class="parameter ">prefix<span class="token operator">: </span><a href="../-search-field-prefix/index.html">SearchFieldPrefix</a></span></span><span class="token punctuation">)</span><span class="clearfix"><span class="floating-right">(<a href="https://github.com/terraware/terraware-server/tree/main/src/main/kotlin/com/terraformation/backend/search/NestedQueryBuilder.kt#L487">source</a>)</span></span></div><p class="paragraph">Builds a database query that returns nested results from a tree of child tables.</p><p class="paragraph">This code produces a somewhat complex result. Understanding it may require some effort. The rest of this comment will try to lay everything out.</p><h1 class=""> Basic usage</h1><p class="paragraph">Uses of this class will follow the same basic pattern everywhere.</p><ol><li><p class="paragraph">Create a <a href="index.html">NestedQueryBuilder</a>.</p></li><li><p class="paragraph">Call <a href="add-select-fields.html">addSelectFields</a> to set the list of fields that should be included in each result.</p></li><li><p class="paragraph">Call <a href="add-sort-fields.html">addSortFields</a> to set the list of fields that should be used to sort the results.</p></li><li><p class="paragraph">Call <a href="add-condition.html">addCondition</a> to set the criteria that should be used to filter the results.</p></li><li><p class="paragraph">Call <a href="to-select-query.html">toSelectQuery</a> to get back a jOOQ <span data-unresolved-link="org.jooq/SelectSeekStepN///PointingToDeclaration/">SelectSeekStepN</span> object representing the query.</p></li><li><p class="paragraph">Call <span data-unresolved-link="org.jooq/SelectSeekStepN/fetch/#/PointingToDeclaration/">SelectSeekStepN.fetch</span> to retrieve the query results.</p></li></ol><p class="paragraph">The filter criteria in step 4 will often involve a subquery; see the &quot;Search criteria&quot; section below for more on that.</p><h1 class=""> Example</h1><p class="paragraph">Suppose you have the following data. (For clarity, this omits irrelevant columns.)</p><div class="sample-container"><pre><code class="block lang-sql" theme="idea">INSERT INTO facilities (id, name) VALUES (10, 'My Seed Bank');<br><br>INSERT INTO species (id, scientific_name) VALUES (1, 'First Species');<br>INSERT INTO species (id, scientific_name) VALUES (2, 'Second Species');<br><br>INSERT INTO accessions (id, facility_id, species_id) VALUES (3, 10, 1);<br>INSERT INTO accessions (id, facility_id, species_id) VALUES (4, 10, 2);<br><br>INSERT INTO bags (accession_id, number) VALUES (3, 'First bag for accession 3');<br>INSERT INTO bags (accession_id, number) VALUES (3, 'Second bag for accession 3');<br><br>INSERT INTO viability_tests (id, accession_id, start_date) VALUES (5, 3, '2021-10-01');<br>INSERT INTO viability_tests (id, accession_id, start_date) VALUES (6, 3, '2021-10-15');<br><br>INSERT INTO viability_test_results (test_id, seeds_germinated) VALUES (5, 10);<br>INSERT INTO viability_test_results (test_id, seeds_germinated) VALUES (5, 20);</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">This represents the following hierarchy.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">- Facility 10, name &quot;My Seed Bank&quot;<br>  - Accession ID 3, species 1 &quot;First Species&quot;<br>     - Bag number &quot;First bag for accession 3&quot;<br>     - Bag number &quot;Second bag for accession 3&quot;<br>     - Viability Test 5, start date 2021-10-01<br>       - Test Result, 10 seeds germinated<br>       - Test Result, 20 seeds germinated<br>     - Viability Test 6, start date 2021-10-15<br>  - Accession ID 4, species 2 &quot;Second Species&quot;, no bags or tests</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Now you construct a query like this, referencing the search fields in <a href="../../com.terraformation.backend.search.table/-accessions-table/index.html">AccessionsTable</a>.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">val rootPrefix = SearchFieldPathPrefix(accessionsTable)<br>val queryBuilder = NestedQueryBuilder(dslContext, rootPrefix)<br><br>queryBuilder.addSelectFields(<br>    listOf(<br>        rootPrefix.resolve(&quot;id&quot;),<br>        rootPrefix.resolve(&quot;speciesName&quot;),<br>        rootPrefix.resolve(&quot;bags.number&quot;),<br>        rootPrefix.resolve(&quot;facility.name&quot;),<br>        rootPrefix.resolve(&quot;viabilityTests.startDate&quot;),<br>        rootPrefix.resolve(&quot;viabilityTests.viabilityTestResults.seedsGerminated&quot;)))<br><br>// You can sort on fields you didn't select, and vice versa, though we won't do that here just<br>// to keep the example easier to follow.<br>queryBuilder.addSortFields(<br>    listOf(<br>        SearchSortField(rootPrefix.resolve(&quot;speciesName&quot;)),<br>        SearchSortField(rootPrefix.resolve(&quot;viabilityTests.startDate&quot;)),<br>        SearchSortField(rootPrefix.resolve(&quot;bags.number&quot;)),<br>        SearchSortField(rootPrefix.resolve(&quot;viabilityTests.viabilityTestResults.seedsGerminated&quot;))))<br><br>val results = queryBuilder.toSelectQuery().fetch()</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">You'll get back a list of results that looks like this, minus the comments, of course:</p><div class="sample-container"><pre><code class="block lang-json" theme="idea">[<br>  # The first sort key is &quot;speciesName&quot;. &quot;First Species&quot; is alphabetically lower than &quot;Second<br>  # Species&quot;, so accession 3 is first in the results list.<br>  {<br>    &quot;id&quot;: &quot;3&quot;,<br>    &quot;speciesName&quot;: &quot;First Species&quot;,<br>    &quot;bags&quot;: [<br>      # The first (and only) sort field under &quot;bags&quot; is the bag number, so this list is<br>      # sorted alphabetically on that value.<br>      { &quot;number&quot;: &quot;First bag for accession 3&quot; },<br>      { &quot;number&quot;: &quot;Second bag for accession 3&quot; }<br>    ],<br>    &quot;facility&quot;: {<br>      # This is a single value, not a list, since an accession only ever has one facility.<br>      &quot;name&quot;: &quot;My Seed Bank&quot;<br>    },<br>    &quot;viabilityTests&quot;: [<br>      # The first sort field under &quot;viabilityTests&quot; is the start date, so this list is sorted<br>      # in ascending start date order.<br>      {<br>        &quot;viabilityTestResults&quot;: [<br>          # The first sort field under &quot;viabilityTests.viabilityTestResults&quot; is &quot;seedsGerminated&quot;,<br>          # so this list is sorted by that.<br>          { &quot;seedsGerminated&quot;: &quot;10&quot; },<br>          { &quot;seedsGerminated&quot;: &quot;20&quot; }<br>        ],<br>        &quot;startDate&quot;: &quot;2021-10-01&quot;<br>      },<br>      {<br>        &quot;startDate&quot;: &quot;2021-10-15&quot;<br>      }<br>    ]<br>  },<br>  {<br>    # Empty lists, and scalar fields with no values, are omitted from the result. Each result<br>    # is a Map&lt;String,Any&gt; which might be implemented as a hashtable, so callers shouldn't<br>    # assume the fields are in any particular order.<br>    &quot;speciesName&quot;: &quot;Second Species&quot;,<br>    &quot;id&quot;: &quot;4&quot;,<br>    &quot;facility&quot;: {<br>      &quot;name&quot;: &quot;My Seed Bank&quot;<br>    }<br>  }<br>]</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h1 class=""> Implementation details</h1><h2 class=""> Field paths</h2><p class="paragraph">Search results are returned as a list of maps of field names to field values. A field value can be a string, a map of field names to field values, or a list of maps of field names to field values. Kotlin doesn't have support for union types, so this gets represented as <code class="lang-kotlin">List&lt;Map&lt;String, Any&gt;&gt;</code>.</p><p class="paragraph">There are thus three styles of search field. Internally, this code refers to them as <strong>scalars</strong> and <strong>sublists</strong> (the latter of which has two styles) to reflect how they're returned in search results.</p><p class="paragraph">Scalar fields are single values, and are always represented as strings in the search results. Scalar field values are either directly stored on main tables (e.g., <code class="lang-kotlin">accessions.total_quantity</code>) or are represented as foreign key columns on main tables and looked up from reference tables (e.g., <code class="lang-kotlin">viability_tests.seed_type_id</code>.)</p><p class="paragraph">Sublist fields, as the name suggests, are containers with their own lists of fields. They come in two flavors: &quot;multi-value&quot; and &quot;single-value.&quot; A multi-value sublist turns into a list of JSON objects in the search results, whereas a single-value sublist turns into a single JSON object. Each of those objects can contain a mix of scalar fields and sublist fields. (There is a way to specify that you don't want sublist fields to be returned as nested JSON objects; the &quot;Flattened sublists&quot; section describes how that works, but we'll ignore it for now and focus on nested sublist fields.)</p><p class="paragraph">Sublist fields aren't directly searchable; they are just containers for scalar fields.</p><p class="paragraph">A nested sublist field is identified by the presence of a <code class="lang-kotlin">.</code> in its name. For example, the field <code class="lang-kotlin">viabilityTests.viabilityTestResults.recordingDate</code> represents a sublist field called <code class="lang-kotlin">viabilityTests</code> each element of which contains a sublist field called <code class="lang-kotlin">viabilityTestResults</code> each element of which contains a scalar field called <code class="lang-kotlin">recordingDate</code>.</p><p class="paragraph">A field name is represented as a <a href="../-search-field-path/index.html">SearchFieldPath</a> which consists of a prefix and a scalar field. The prefix is represented as a <a href="../-search-field-prefix/index.html">SearchFieldPrefix</a> and includes a list of sublist fields which form a path to the location of the scalar field (<code class="lang-kotlin">viabilityTests</code> and <code class="lang-kotlin">viabilityTestResults</code> in the above example). The prefix also includes a &quot;root table&quot; (in the form of a <a href="../-search-table/index.html">SearchTable</a>) that identifies where in the application's data model the prefix begins. In the example, the root table would indicate that the fields are all under the &quot;accessions&quot; part of the data model.</p><p class="paragraph">A filesystem analogy might make the pieces easier to understand:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea"># This is the root table; everything else is relative to it.<br>cd /organizations/projects/sites/facilities/accessions<br># This is two sublist fields followed by a scalar field.<br>cat viabilityTests/viabilityTestResults/recordingDate</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Query hierarchy</h2><p class="paragraph">The query is represented as a tree of <a href="index.html">NestedQueryBuilder</a>s. The root node represents the query as a whole, and each child node represents the query for a sublist field. Each node has a <a href="../-search-field-prefix/index.html">SearchFieldPrefix</a>.</p><p class="paragraph">For example, a search field of <code class="lang-kotlin">viabilityTests.viabilityTestResults.recordingDate</code> with a root table of <code class="lang-kotlin">accessions</code> would be turned into a structure something like this YAML document:</p><div class="sample-container"><pre><code class="block lang-yaml" theme="idea">prefix:<br>  root: accessions<br>  sublists: []<br>scalarFields: []<br>sublistQueryBuilders:<br>  viabilityTests:<br>    prefix:<br>      # This prefix refers to the viabilityTests sublist under accessions; the root<br>      # is the same as the parent's root.<br>      root: accessions<br>      sublists: [viabilityTests]<br>    scalarFields: []<br>    sublistQueryBuilders:<br>      viabilityTestResults:<br>        prefix:<br>          # This prefix refers to the viabilityTestResults sublist under the viabilityTests<br>          # sublist under accessions. As before, the root is the same as the parent's.<br>          root: accessions<br>          sublists: [viabilityTests, viabilityTestResults]<br>        scalarFields: [recordingDate]<br>        sublistQueryBuilders: []</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Field names are always evaluated relative to the current node (that is, the prefix is stripped off to get a relative name). So for example, the middle node in the above hierarchy strips off its prefix and treats the search field as having a name of <code class="lang-kotlin">viabilityTestResults.recordingDate</code>. Because that name contains a <code class="lang-kotlin">.</code> character, the middle node needs to peel off the part before the <code class="lang-kotlin">.</code> and treat the field as a sublist called <code class="lang-kotlin">viabilityTestResults</code>.</p><p class="paragraph">The examples in this document treat field names as string values. Although the client-facing API accepts field names as period-separated strings, internally they are represented as <a href="../-search-field-path/index.html">SearchFieldPath</a> objects, which are automatically constructed during deserialization of the JSON request payloads.</p><h2 class=""> Multisets</h2><p class="paragraph">This implementation is heavily dependent on implementation details of jOOQ's &quot;multiset&quot; operator. For background on multisets, please see <a href="https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/multiset-value-constructor/">the jOOQ docs</a> or for a deeper dive, <a href="https://blog.jooq.org/jooq-3-15s-new-multiset-operator-will-change-how-you-think-about-sql/">this blog post</a> introducing the feature.</p><p class="paragraph">Conceptually, this works kind of like the examples in the docs: it constructs a query on the database table for the root <a href="../-search-table/index.html">SearchTable</a> where the list of fields includes <span data-unresolved-link="org.jooq.impl/DSL/multiset/#org.jooq.TableLike[TypeParam(bounds=[org.jooq.Record])]/PointingToDeclaration/">DSL.multiset</span> values that hold child records. Those child records can, in turn, have their own multiset fields if they themselves have children, e.g., an accession has viability tests each of which has viabilityTestResults.</p><p class="paragraph">Under the covers, on PostgreSQL, jOOQ turns a multiset into an aggregation operation over a subquery. The aggregation function returns a JSON array where each element of the array represents a row of results from the subquery. Each of those elements is itself a JSON array of the field values in the subquery's SELECT clause. In other words, the multiset turns into a two-dimensional array indexed by row number and field position. This implementation detail will become important later.</p><h2 class=""> Search criteria</h2><p class="paragraph">Say you have an accession with two bags, &quot;A&quot; and &quot;B&quot;. The user does a search with a root table of <code class="lang-kotlin">accessions</code> and asks for results containing bag &quot;A&quot;.</p><p class="paragraph">There are two ways that could work, neither of them wrong: treat the search criterion as a filter on bag numbers (returning a result with a single bag) or treat it as a filter on accessions (returning a result with two bags).</p><p class="paragraph">Our product decision is to do the latter. Search criteria control which top-level results are returned, but each result includes the full set of values for all its fields. When you search for bag &quot;A&quot;, what you're really telling the system is that you want all <i>accessions</i> that have a bag called &quot;A&quot;. And for each accession that matches the search criteria, you get back the full list of bags.</p><p class="paragraph">That's relevant here because it changes what the SQL looks like: we don't apply any search criteria to the multiset subqueries, because we want to return the full set of data for any accessions that match the criteria.</p><p class="paragraph">Instead, user-supplied search criteria are turned into a subquery which is used to generate a list of accession IDs. The nested query then selects the values of all the requested fields for the accessions on that list. The subquery is constructed in <span data-unresolved-link="com.terraformation.backend.search/SearchService/filterResults/#com.terraformation.backend.search.SearchFieldPrefix#com.terraformation.backend.search.SearchNode/PointingToDeclaration/">SearchService.filterResults</span>.</p><p class="paragraph">In the above example, the query is structured like this (pseudocode):</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">SELECT accessions.id,<br>       MULTISET(SELECT bags.number<br>                FROM bags<br>                WHERE accessions.id = bags.accession_id)<br>FROM accessions<br>WHERE accessions.id IN (<br>    SELECT accessions.id<br>    FROM accessions<br>    JOIN bags ON accessions.id = bags.accession_id<br>    WHERE bags.number = 'A')</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">The key point is that the multiset will contain <i>all</i> the bags for the accession.</p><h2 class=""> Ordering</h2><p class="paragraph">Unfortunately, the happy-path usage of multisets breaks down once you need to sort the results based on a field in a child table, because the ordering needs to bubble up through the rest of the query too. For example, say you have two accessions each with two bags:</p><ul><li><p class="paragraph">Accession 1: Bags X and Y</p></li><li><p class="paragraph">Accession 2: Bags A and B</p></li></ul><p class="paragraph">You specify that you want to sort the search results in ascending order of bag number. In that case, you want accession 2 to appear before accession 1 because bag A comes before the others. You also want each accession's bag numbers to be sorted.</p><p class="paragraph">What does that query look like, though? Ordering the bags for each accession is simple enough; just put an <code class="lang-kotlin">ORDER BY</code> on the subquery. But how do you sort the accessions at the top level of the query?</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">SELECT accessions.id,<br>       MULTISET(SELECT bags.id, bags.number<br>                FROM bags<br>                WHERE accessions.id = bags.accession_id<br>                ORDER BY bags.number)<br>FROM accessions<br>WHERE accessions.id IN (...)<br>ORDER BY ?????</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">It turns out there is no officially-supported way for the outer query to peek inside the multiset. If you want to do it portably, for now <a href="https://stackoverflow.com/questions/69577525/how-to-order-by-values-from-nested-multisets">you have to repeat the subquery.</a></p><p class="paragraph">Doing it that way would make queries more expensive, so instead we break portability and rely on the way multisets are implemented on PostgreSQL. Recall that they turn into two-dimensional arrays.</p><p class="paragraph">We know that the multiset is already sorted correctly because the subquery has an <code class="lang-kotlin">ORDER BY</code> clause: the first row in the multiset will always be the one that should determine the sort order of the parent row. In the example query, the first row of the multiset will have bag number &quot;X&quot; for accession 1 and &quot;A&quot; for accession 2.</p><p class="paragraph">We also know the order of the fields in the multiset's subquery. In the example, the field we want to sort on is the second one, <code class="lang-kotlin">bags.number</code>.</p><p class="paragraph">Putting the two together, and remembering that JSON arrays are 0-indexed, we want to do something like this (note the column alias on the multiset):</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">SELECT accessions.id,<br>       MULTISET(<br>           SELECT bags.id, bags.number<br>           FROM bags<br>           WHERE accessions.id = bags.accession_id<br>           ORDER BY bags.number<br>       ) AS bags_multiset<br>FROM accessions<br>WHERE accessions.id IN (...)<br>ORDER BY bags_multiset[0][1]</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Lateral joins</h2><p class="paragraph">Unfortunately, an <code class="lang-kotlin">ORDER BY</code> clause can't use a computed value from the <code class="lang-kotlin">SELECT</code> clause of the same query. So in the above example, <code class="lang-kotlin">ORDER BY bags_multiset[0][1]</code> won't work because <code class="lang-kotlin">bags_multiset</code> is an alias for the output of a computation, not an input to the query.</p><p class="paragraph">The solution is to move the multisets out of the main query. We do this using <a href="https://www.postgresql.org/docs/13/queries-table-expressions.html#QUERIES-LATERAL">lateral subqueries</a> resulting in a structure like</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">SELECT accessions.id, bags_multiset<br>FROM accessions<br>LEFT JOIN LATERAL (<br>    SELECT MULTISET(<br>        SELECT bags.id, bags.number<br>        FROM bags<br>        WHERE accessions.id = bags.accession_id<br>        ORDER BY bags.number<br>    ) AS bags_multiset<br>)<br>WHERE accessions.id IN (...)<br>ORDER BY bags_multiset[0][1]</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Here the <code class="lang-kotlin">bags_multiset</code> column is computed in the subquery and is an input to the top-level query, so we can reference it in the <code class="lang-kotlin">ORDER BY</code> clause.</p><h2 class=""> Enums</h2><p class="paragraph">Some fields are stored as integer IDs in the database, but rendered as human-readable strings in the UI. For example, an accession with <code class="lang-kotlin">state_id = 10</code> is shown as having a state of <code class="lang-kotlin">Pending</code> for a user using the service in English. These fields have a fixed set of values and get turned into enums in the generated Kotlin code.</p><p class="paragraph">When the user sorts by a field that maps to an enum, we want to order it based on the (possibly localized) display name, not on the numeric ID. Currently, we do that by generating a <code class="lang-kotlin">CASE</code> expression to map the IDs to their display names so the database can sort on them.</p><h2 class=""> Flattened sublists</h2><p class="paragraph">Most of the discussion above was concerned with how we return search results in tree-structured form. But sometimes a tree structure isn't the right representation. Think, for example, of exporting search results to a CSV file: by definition there is no way to nest values, and if a sublist has multiple values for a field, they need to be represented as multiple rows. In short, the results need to be returned as a series of flat records where the values are always scalar.</p><p class="paragraph">To support this use case, the search code has the ability to &quot;flatten&quot; a sublist. Flattening a sublist causes the sublist's fields to be merged into the parent. The sublist no longer appears explicitly as a field in the search results. If the sublist is multi-value and there's more than one list entry, there will be one copy of the parent for each entry of the sublist.</p><p class="paragraph">A flattened sublist is specified by using an underscore <code class="lang-kotlin">_</code> rather than a period <code class="lang-kotlin">.</code> as the delimiter after the sublist name. Internally, a flattened sublist is distinguished from a nested one by the <a href="../-sublist-field/is-flattened.html">SublistField.isFlattened</a> property.</p><p class="paragraph">A simple pair of examples should help illustrate what flattening does. In the first search result, the caller asked for <code class="lang-kotlin">id</code> and <code class="lang-kotlin">bags.number</code> in the `accessions table.</p><div class="sample-container"><pre><code class="block lang-json" theme="idea">[<br>  { &quot;id&quot;: &quot;1&quot;, &quot;bags&quot;: [ { &quot;number&quot;: &quot;200&quot; }, { &quot;number&quot;: &quot;300&quot; } ] },<br>  { &quot;id&quot;: &quot;2&quot;, &quot;bags&quot;: [ { &quot;number&quot;: &quot;400&quot; } ] }<br>]</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">In the second, the caller asked for <code class="lang-kotlin">id</code> and <code class="lang-kotlin">bags_number</code>, using an underscore to ask the system to flatten the <code class="lang-kotlin">bags</code> sublist.</p><div class="sample-container"><pre><code class="block lang-json" theme="idea">[<br>  { &quot;id&quot;: &quot;1&quot;, &quot;bags_number&quot;: &quot;200&quot; },<br>  { &quot;id&quot;: &quot;1&quot;, &quot;bags_number&quot;: &quot;300&quot; },<br>  { &quot;id&quot;: &quot;2&quot;, &quot;bags_number&quot;: &quot;400&quot; },<br>]</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Two things are happening here: the <code class="lang-kotlin">number</code> field from the <code class="lang-kotlin">bags</code> sublist is included as a top-level field in each result, and there are now two search results for ID 1 because there were two values in the <code class="lang-kotlin">bags</code> sublist.</p><p class="paragraph">Flattened sublists are potentially useful even when you don't need all the search results to be completely tabular. In particular, they can simplify the representation of fields from single-value sublists. For example, compare what happens when you ask for <code class="lang-kotlin">facility.name</code>:</p><div class="sample-container"><pre><code class="block lang-json" theme="idea">[ { &quot;facility&quot;: { &quot;name&quot;: &quot;My Seed Bank&quot; } } ]</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">and <code class="lang-kotlin">facility_name</code>:</p><div class="sample-container"><pre><code class="block lang-json" theme="idea">[ { &quot;facility_name&quot;: &quot;My Seed Bank&quot; } ]</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">It is possible to mix nested and flattened sublists: nested sublists can contain flattened ones but not the other way around. Mixing the two styles is not useful for the &quot;export to CSV&quot; case (when you wouldn't want any nesting at all) but is useful for the single-value-sublist scenario in the second pair of examples above.</p><p class="paragraph">Constructing the SQL queries for flattened sublists is far simpler than for nested ones. Each flattened sublist turns into a simple <code class="lang-kotlin">LEFT JOIN</code> and there is no need for multisets at all. The results of a SQL join already have the right structure: the columns from all the joined tables are mixed together in a single result row, and there are separate results if one of the joined tables has multiple rows that match the join criterion.</p><h2 class=""> Aliases</h2><p class="paragraph">There is a special &quot;alias&quot; field type, represented internally by an <a href="../../com.terraformation.backend.search.field/-alias-field/index.html">AliasField</a>. It allows a given field to be referenced by an alternate name. The target of the alias is used to construct the database query, and the alias name is used as the name of the field in the search results.</p><p class="paragraph">For example, the <code class="lang-kotlin">bagNumber</code> field in the accessions table is an alias for <code class="lang-kotlin">bags_number</code>. If you ask for <code class="lang-kotlin">id</code> and <code class="lang-kotlin">bagNumber</code>, you'll get back a flattened result like,</p><div class="sample-container"><pre><code class="block lang-json" theme="idea">[<br>  { &quot;id&quot;: &quot;1&quot;, &quot;bagNumber&quot;: &quot;200&quot; },<br>  { &quot;id&quot;: &quot;1&quot;, &quot;bagNumber&quot;: &quot;300&quot; },<br>  { &quot;id&quot;: &quot;2&quot;, &quot;bagNumber&quot;: &quot;400&quot; },<br>]</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Aliases allow us to maintain backward compatibility with the original accession search API, which didn't have any concept of sublists and always flattened all search results. Flattened sublists are a more general implementation, and the old field names are now aliases for flattened field paths.</p><p class="paragraph">The target of an alias can't contain nested sublists, just flattened ones.</p></div></div>
  </div>
  <div class="tabbedcontent">
    <div class="tabs-section" tabs-section="tabs-section"><button class="section-tab" data-active="" data-togglable="CONSTRUCTOR,TYPE,PROPERTY,FUNCTION">Members</button></div>
    <div class="tabs-section-body">
      <div data-togglable="CONSTRUCTOR">
        <h2 class="">Constructors</h2>
        <div class="table"><a data-name="648845251%2FConstructors%2F769193423" anchor-label="NestedQueryBuilder" id="648845251%2FConstructors%2F769193423" data-filterable-set=":dokkaHtml/main"></a>
          <div class="table-row" data-togglable="CONSTRUCTOR" data-filterable-current=":dokkaHtml/main" data-filterable-set=":dokkaHtml/main">
            <div class="main-subrow keyValue ">
              <div class=""><span class="inline-flex">
                  <div><a href="-nested-query-builder.html"><span>Nested</span><wbr></wbr><span>Query</span><wbr></wbr><span><span>Builder</span></span></a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="648845251%2FConstructors%2F769193423"></span>
                    <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
                  </span></span></div>
              <div>
                <div class="title">
                  <div class="platform-hinted " data-platform-hinted="data-platform-hinted"><div class="content sourceset-dependent-content" data-active="" data-togglable=":dokkaHtml/main"><div class="symbol monospace"><span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="parameters "><span class="parameter ">dslContext<span class="token operator">: </span><span data-unresolved-link="org.jooq/DSLContext///PointingToDeclaration/">DSLContext</span><span class="token punctuation">, </span></span><span class="parameter ">prefix<span class="token operator">: </span><a href="../-search-field-prefix/index.html">SearchFieldPrefix</a></span></span><span class="token punctuation">)</span></div></div></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div data-togglable="FUNCTION">
        <h2 class="">Functions</h2>
        <div class="table"><a data-name="412083533%2FFunctions%2F769193423" anchor-label="addCondition" id="412083533%2FFunctions%2F769193423" data-filterable-set=":dokkaHtml/main"></a>
          <div class="table-row" data-filterable-current=":dokkaHtml/main" data-filterable-set=":dokkaHtml/main">
            <div class="main-subrow keyValue ">
              <div class=""><span class="inline-flex">
                  <div><a href="add-condition.html"><span>add</span><wbr></wbr><span><span>Condition</span></span></a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="412083533%2FFunctions%2F769193423"></span>
                    <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
                  </span></span></div>
              <div>
                <div class="title">
                  <div class="platform-hinted " data-platform-hinted="data-platform-hinted"><div class="content sourceset-dependent-content" data-active="" data-togglable=":dokkaHtml/main"><div class="symbol monospace"><span class="token keyword"></span><span class="token keyword">fun </span><a href="add-condition.html"><span class="token function">addCondition</span></a><span class="token punctuation">(</span><span class="parameters "><span class="parameter ">condition<span class="token operator">: </span><span data-unresolved-link="org.jooq/Condition///PointingToDeclaration/">Condition</span></span></span><span class="token punctuation">)</span></div><div class="brief "><p class="paragraph">Adds a search condition to this query.</p></div></div></div>
                </div>
              </div>
            </div>
          </div>
<a data-name="-701344362%2FFunctions%2F769193423" anchor-label="addSelectFields" id="-701344362%2FFunctions%2F769193423" data-filterable-set=":dokkaHtml/main"></a>
          <div class="table-row" data-filterable-current=":dokkaHtml/main" data-filterable-set=":dokkaHtml/main">
            <div class="main-subrow keyValue ">
              <div class=""><span class="inline-flex">
                  <div><a href="add-select-fields.html"><span>add</span><wbr></wbr><span>Select</span><wbr></wbr><span><span>Fields</span></span></a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="-701344362%2FFunctions%2F769193423"></span>
                    <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
                  </span></span></div>
              <div>
                <div class="title">
                  <div class="platform-hinted " data-platform-hinted="data-platform-hinted"><div class="content sourceset-dependent-content" data-active="" data-togglable=":dokkaHtml/main"><div class="symbol monospace"><span class="token keyword"></span><span class="token keyword">fun </span><a href="add-select-fields.html"><span class="token function">addSelectFields</span></a><span class="token punctuation">(</span><span class="parameters "><span class="parameter ">fields<span class="token operator">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-collection/index.html">Collection</a><span class="token operator">&lt;</span><span class="token keyword"></span><a href="../-search-field-path/index.html">SearchFieldPath</a><span class="token operator">&gt;</span></span></span><span class="token punctuation">)</span></div><div class="brief "><p class="paragraph">Includes a set of fields in the search results.</p></div></div></div>
                </div>
              </div>
            </div>
          </div>
<a data-name="540934321%2FFunctions%2F769193423" anchor-label="addSortFields" id="540934321%2FFunctions%2F769193423" data-filterable-set=":dokkaHtml/main"></a>
          <div class="table-row" data-filterable-current=":dokkaHtml/main" data-filterable-set=":dokkaHtml/main">
            <div class="main-subrow keyValue ">
              <div class=""><span class="inline-flex">
                  <div><a href="add-sort-fields.html"><span>add</span><wbr></wbr><span>Sort</span><wbr></wbr><span><span>Fields</span></span></a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="540934321%2FFunctions%2F769193423"></span>
                    <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
                  </span></span></div>
              <div>
                <div class="title">
                  <div class="platform-hinted " data-platform-hinted="data-platform-hinted"><div class="content sourceset-dependent-content" data-active="" data-togglable=":dokkaHtml/main"><div class="symbol monospace"><span class="token keyword"></span><span class="token keyword">fun </span><a href="add-sort-fields.html"><span class="token function">addSortFields</span></a><span class="token punctuation">(</span><span class="parameters "><span class="parameter ">sortFields<span class="token operator">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html">List</a><span class="token operator">&lt;</span><span class="token keyword"></span><a href="../-search-sort-field/index.html">SearchSortField</a><span class="token operator">&gt;</span></span></span><span class="token punctuation">)</span></div><div class="brief "><p class="paragraph">Uses a list of fields to sort the search results.</p></div></div></div>
                </div>
              </div>
            </div>
          </div>
<a data-name="1984757949%2FFunctions%2F769193423" anchor-label="convertToMap" id="1984757949%2FFunctions%2F769193423" data-filterable-set=":dokkaHtml/main"></a>
          <div class="table-row" data-filterable-current=":dokkaHtml/main" data-filterable-set=":dokkaHtml/main">
            <div class="main-subrow keyValue ">
              <div class=""><span class="inline-flex">
                  <div><a href="convert-to-map.html"><span>convert</span><wbr></wbr><span>To</span><wbr></wbr><span><span>Map</span></span></a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="1984757949%2FFunctions%2F769193423"></span>
                    <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
                  </span></span></div>
              <div>
                <div class="title">
                  <div class="platform-hinted " data-platform-hinted="data-platform-hinted"><div class="content sourceset-dependent-content" data-active="" data-togglable=":dokkaHtml/main"><div class="symbol monospace"><span class="token keyword"></span><span class="token keyword">fun </span><a href="convert-to-map.html"><span class="token function">convertToMap</span></a><span class="token punctuation">(</span><span class="parameters "><span class="parameter ">record<span class="token operator">: </span><span data-unresolved-link="org.jooq/Record///PointingToDeclaration/">Record</span></span></span><span class="token punctuation">)</span><span class="token operator">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html">Map</a><span class="token operator">&lt;</span><span class="token keyword"></span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html">String</a><span class="token punctuation">, </span><span class="token keyword"></span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html">Any</a><span class="token operator">&gt;</span><span class="token operator">?</span></div><div class="brief "><p class="paragraph">Converts a row of results of the SELECT statement into a map of scalar and sublist fields.</p></div></div></div>
                </div>
              </div>
            </div>
          </div>
<a data-name="2018771561%2FFunctions%2F769193423" anchor-label="toSelectQuery" id="2018771561%2FFunctions%2F769193423" data-filterable-set=":dokkaHtml/main"></a>
          <div class="table-row" data-filterable-current=":dokkaHtml/main" data-filterable-set=":dokkaHtml/main">
            <div class="main-subrow keyValue ">
              <div class=""><span class="inline-flex">
                  <div><a href="to-select-query.html"><span>to</span><wbr></wbr><span>Select</span><wbr></wbr><span><span>Query</span></span></a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="2018771561%2FFunctions%2F769193423"></span>
                    <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
                  </span></span></div>
              <div>
                <div class="title">
                  <div class="platform-hinted " data-platform-hinted="data-platform-hinted"><div class="content sourceset-dependent-content" data-active="" data-togglable=":dokkaHtml/main"><div class="symbol monospace"><span class="token keyword"></span><span class="token keyword">fun </span><a href="to-select-query.html"><span class="token function">toSelectQuery</span></a><span class="token punctuation">(</span><span class="parameters "><span class="parameter ">distinct<span class="token operator">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html">Boolean</a><span class="token operator"> = </span><span class="token boolean">false</span></span></span><span class="token punctuation">)</span><span class="token operator">: </span><span data-unresolved-link="org.jooq/SelectSeekStepN///PointingToDeclaration/">SelectSeekStepN</span><span class="token operator">&lt;</span><span class="token keyword"></span><span data-unresolved-link="org.jooq/Record///PointingToDeclaration/">Record</span><span class="token operator">&gt;</span></div><div class="brief "><p class="paragraph">Returns a jOOQ query object for the currently-configured query. Once this method is called, attempts to modify its field lists or conditions will throw <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-illegal-state-exception/index.html">IllegalStateException</a>.</p></div></div></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
      <div class="footer">
        <span class="go-to-top-icon"><a href="#content" id="go-to-top-link"></a></span><span>© 2023 Copyright</span><span
                class="pull-right"><span>Generated by </span><a
                href="https://github.com/Kotlin/dokka"><span>dokka</span><span class="padded-icon"></span></a></span>
      </div>
    </div>
</div>
</body>
</html>
