<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<database name="terraware" schema="public" type="PostgreSQL - 13.1 (Debian 13.1-1.pgdg100+1)">
   <tables>
      <table name="gbif_distributions" numRows="0" remarks="Information about geographic distribution of species and their conservation statuses." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="taxon_id" nullable="false" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="country_code" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="establishment_means" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="occurrence_status" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="threat_status" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <index name="gbif_distributions_taxon_id_idx" unique="false">
            <column ascending="true" name="taxon_id"/>
         </index>
      </table>
      <table name="gbif_name_words" numRows="0" remarks="Inverted index of lower-cased words from species and family names in the GBIF backbone dataset. Used to support fast per-word prefix searches." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="gbif_name_id" nullable="false" remarks="" size="19" type="int8" typeCode="-5">
            <parent column="id" foreignKey="gbif_name_words_gbif_name_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="gbif_names"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="word" nullable="false" remarks="" size="2147483647" type="text" typeCode="12"/>
         <index name="gbif_name_words_gbif_name_id_idx" unique="false">
            <column ascending="true" name="gbif_name_id"/>
         </index>
         <index name="gbif_name_words_word_gbif_name_id_idx" unique="false">
            <column ascending="true" name="word"/>
            <column ascending="true" name="gbif_name_id"/>
         </index>
      </table>
      <table name="gbif_names" numRows="0" remarks="Scientific and vernacular names from the GBIF backbone dataset. Names are not required to be unique." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="19" type="int8" typeCode="-5">
            <child column="gbif_name_id" foreignKey="gbif_name_words_gbif_name_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="gbif_name_words"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="taxon_id" nullable="false" remarks="" size="19" type="int8" typeCode="-5">
            <parent column="taxon_id" foreignKey="gbif_names_taxon_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="gbif_taxa"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name" nullable="false" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="language" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="is_scientific" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="gbif_names_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="gbif_names__name_trgm" unique="false">
            <column ascending="true" name="name"/>
         </index>
         <index name="gbif_names_name_is_scientific_idx" unique="false">
            <column ascending="true" name="name"/>
            <column ascending="true" name="is_scientific"/>
         </index>
         <index name="gbif_names_taxon_id_idx" unique="false">
            <column ascending="true" name="taxon_id"/>
         </index>
      </table>
      <table name="gbif_taxa" numRows="0" remarks="Taxonomic data about species and families. A subset of the GBIF backbone dataset." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="taxon_id" nullable="false" remarks="" size="19" type="int8" typeCode="-5">
            <child column="taxon_id" foreignKey="gbif_names_taxon_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="gbif_names"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="dataset_id" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="parent_name_usage_id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="accepted_name_usage_id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="original_name_usage_id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="scientific_name" nullable="false" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="canonical_name" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="generic_name" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="specific_epithet" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="infraspecific_epithet" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="taxon_rank" nullable="false" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="taxonomic_status" nullable="false" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="nomenclatural_status" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="phylum" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="class" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="order" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="family" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="17" name="genus" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <primaryKey column="taxon_id" sequenceNumberInPK="1"/>
         <index name="gbif_taxa_pkey" unique="true">
            <column ascending="true" name="taxon_id"/>
         </index>
      </table>
      <table name="gbif_vernacular_names" numRows="0" remarks="Vernacular names for species and families. Part of the GBIF backbone dataset." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="taxon_id" nullable="false" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="vernacular_name" nullable="false" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="language" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="country_code" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <index name="gbif_vernacular_names_taxon_id_idx" unique="false">
            <column ascending="true" name="taxon_id"/>
         </index>
      </table>
      <table name="organizations" numRows="0" remarks="Top-level information about organizations." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="Unique numeric identifier of the organization." size="19" type="int8" typeCode="-5">
            <child column="organization_id" foreignKey="batches_organization_id_fkey" implied="false" onDeleteCascade="true" schema="nursery" table="batches"/>
            <child column="organization_id" foreignKey="species_organization_id_fkey" implied="false" onDeleteCascade="true" schema="public" table="species"/>
            <child column="organization_id" foreignKey="planting_sites_organization_id_fkey" implied="false" onDeleteCascade="true" schema="tracking" table="planting_sites"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="2" name="created_time" nullable="false" remarks="" size="35" type="timestamptz" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="3" name="modified_time" nullable="false" remarks="" size="35" type="timestamptz" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="4" name="disabled_time" nullable="true" remarks="" size="35" type="timestamptz" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="country_code" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="country_subdivision_code" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="description" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="created_by" nullable="false" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="modified_by" nullable="false" remarks="" size="19" type="int8" typeCode="-5"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="organization_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="(((country_subdivision_code IS NULL) OR (substr(country_subdivision_code, 1, 2) = country_code)))" name="country_code_matches_subdivision"/>
      </table>
      <table name="species" numRows="0" remarks="Per-organization information about species." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="19" type="int8" typeCode="-5">
            <child column="species_id" foreignKey="batches_species_id_fkey" implied="false" onDeleteCascade="false" schema="nursery" table="batches"/>
            <child column="species_id" foreignKey="species_problems_species_id_fkey" implied="false" onDeleteCascade="true" schema="public" table="species_problems"/>
            <child column="species_id" foreignKey="accessions_species_id_fkey" implied="false" onDeleteCascade="false" schema="seedbank" table="accessions"/>
            <child column="species_id" foreignKey="plantings_species_id_fkey" implied="false" onDeleteCascade="false" schema="tracking" table="plantings"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="organization_id" nullable="false" remarks="" size="19" type="int8" typeCode="-5">
            <parent column="id" foreignKey="species_organization_id_fkey" implied="false" onDeleteCascade="true" schema="public" table="organizations"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="scientific_name" nullable="false" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="common_name" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="family_name" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="endangered" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="rare" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="growth_form_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="seed_storage_behavior_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="created_by" nullable="false" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="10" name="created_time" nullable="false" remarks="" size="35" type="timestamptz" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="modified_by" nullable="false" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="12" name="modified_time" nullable="false" remarks="" size="35" type="timestamptz" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="deleted_by" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="14" name="deleted_time" nullable="true" remarks="" size="35" type="timestamptz" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="15" name="checked_time" nullable="true" remarks="If non-null, when the species was checked for possible suggested edits. If null, the species has not been checked yet." size="35" type="timestamptz" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="initial_scientific_name" nullable="false" remarks="" size="2147483647" type="text" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="species_pkey1" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="species__not_checked_ix" unique="false">
            <column ascending="true" name="id"/>
         </index>
         <index name="species_organization_id_initial_scientific_name_idx" unique="false">
            <column ascending="true" name="organization_id"/>
            <column ascending="true" name="initial_scientific_name"/>
         </index>
         <index name="species_organization_id_scientific_name_key" unique="true">
            <column ascending="true" name="organization_id"/>
            <column ascending="true" name="scientific_name"/>
         </index>
      </table>
      <table name="species_problem_fields" numRows="1" remarks="(Enum) Species fields that can be scanned for problems." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="field_id" foreignKey="species_problems_field_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="species_problems"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="2147483647" type="text" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="species_problem_fields_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
      </table>
      <table name="species_problem_types" numRows="3" remarks="(Enum) Specific types of problems that can be detected in species data." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="type_id" foreignKey="species_problems_type_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="species_problems"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="2147483647" type="text" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="species_problem_types_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
      </table>
      <table name="species_problems" numRows="0" remarks="Problems found in species data. Rows are deleted from this table when the problem is marked as ignored by the user or the user accepts the suggested fix." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="species_id" nullable="false" remarks="" size="19" type="int8" typeCode="-5">
            <parent column="id" foreignKey="species_problems_species_id_fkey" implied="false" onDeleteCascade="true" schema="public" table="species"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="field_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="species_problems_field_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="species_problem_fields"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="type_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="species_problems_type_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="species_problem_types"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="6" id="4" name="created_time" nullable="false" remarks="" size="35" type="timestamptz" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="suggested_value" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="species_problems_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="species_problems_species_id_idx" unique="false">
            <column ascending="true" name="species_id"/>
         </index>
      </table>
   </tables>
   <routines>
      <routine dataAccess="MODIFIES" deterministic="true" name="_postgis_deprecate" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
  curver_text text;
BEGIN
  --
  -- Raises a NOTICE if it was deprecated in this version,
  -- a WARNING if in a previous version (only up to minor version checked)
  --
    curver_text := '3.0.3';
    IF split_part(curver_text,'.',1)::int > split_part(version,'.',1)::int OR
       ( split_part(curver_text,'.',1) = split_part(version,'.',1) AND
         split_part(curver_text,'.',2) != split_part(version,'.',2) )
    THEN
      RAISE WARNING '% signature was deprecated in %. Please use %', oldname, version, newname;
    ELSE
      RAISE DEBUG '% signature was deprecated in %. Please use %', oldname, version, newname;
    END IF;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_postgis_index_extent" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[_postgis_gserialized_index_extent]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_postgis_join_selectivity" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[_postgis_gserialized_joinsel]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_postgis_pgsql_version" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN split_part(s,'.',1)::integer > 9 THEN split_part(s,'.',1) || '0' ELSE split_part(s,'.', 1) || split_part(s,'.', 2) END AS v
	FROM substring(version(), 'PostgreSQL ([0-9\.]+)') AS s;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_postgis_scripts_pgsql_version" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[SELECT '130'::text AS version]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_postgis_selectivity" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[_postgis_gserialized_sel]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_postgis_stats" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[_postgis_gserialized_stats]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_3ddfullywithin" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_dfullywithin3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_3ddwithin" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_dwithin3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_3dintersects" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_3DIntersects]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_asgml" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_asGML]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_asx3d" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_asX3D]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_bestsrid" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_bestsrid]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_concavehull" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
	DECLARE
	vexhull public.geometry;
	var_resultgeom public.geometry;
	var_inputgeom public.geometry;
	vexring public.geometry;
	cavering public.geometry;
	cavept public.geometry[];
	seglength double precision;
	var_tempgeom public.geometry;
	scale_factor float := 1;
	i integer;
	BEGIN
		-- First compute the ConvexHull of the geometry
		vexhull := public.ST_ConvexHull(param_inputgeom);
		var_inputgeom := param_inputgeom;
		--A point really has no concave hull
		IF public.ST_GeometryType(vexhull) = 'ST_Point' OR public.ST_GeometryType(vexHull) = 'ST_LineString' THEN
			RETURN vexhull;
		END IF;

		-- convert the hull perimeter to a linestring so we can manipulate individual points
		vexring := CASE WHEN public.ST_GeometryType(vexhull) = 'ST_LineString' THEN vexhull ELSE public.ST_ExteriorRing(vexhull) END;
		IF abs(public.ST_X(public.ST_PointN(vexring,1))) < 1 THEN --scale the geometry to prevent stupid precision errors - not sure it works so make low for now
			scale_factor := 100;
			vexring := public.ST_Scale(vexring, scale_factor,scale_factor);
			var_inputgeom := public.ST_Scale(var_inputgeom, scale_factor, scale_factor);
			--RAISE NOTICE 'Scaling';
		END IF;
		seglength := public.ST_Length(vexring)/least(public.ST_NPoints(vexring)*2,1000) ;

		vexring := public.ST_Segmentize(vexring, seglength);
		-- find the point on the original geom that is closest to each point of the convex hull and make a new linestring out of it.
		cavering := public.ST_Collect(
			ARRAY(

				SELECT
					public.ST_ClosestPoint(var_inputgeom, pt ) As the_geom
					FROM (
						SELECT  public.ST_PointN(vexring, n ) As pt, n
							FROM
							generate_series(1, public.ST_NPoints(vexring) ) As n
						) As pt

				)
			)
		;

		var_resultgeom := public.ST_MakeLine(geom)
			FROM public.ST_Dump(cavering) As foo;

		IF public.ST_IsSimple(var_resultgeom) THEN
			var_resultgeom := public.ST_MakePolygon(var_resultgeom);
			--RAISE NOTICE 'is Simple: %', var_resultgeom;
		ELSE 
			--RAISE NOTICE 'is not Simple: %', var_resultgeom;
			var_resultgeom := public.ST_ConvexHull(var_resultgeom);
		END IF;

		IF scale_factor > 1 THEN -- scale the result back
			var_resultgeom := public.ST_Scale(var_resultgeom, 1/scale_factor, 1/scale_factor);
		END IF;

		-- make sure result covers original (#3638)
		-- Using ST_UnaryUnion since SFCGAL doesn't replace with its own implementation
		-- and SFCGAL one chokes for some reason
		var_resultgeom := public.ST_UnaryUnion(public.ST_Collect(param_inputgeom, var_resultgeom) );
		RETURN var_resultgeom;

	END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_contains" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[contains]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_containsproperly" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[containsproperly]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_coveredby" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_coveredby]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_covers" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_covers]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_crosses" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[crosses]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_dfullywithin" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_dfullywithin]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_distancetree" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_distance_tree]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_distanceuncached" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_distance_uncached]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_dwithin" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_dwithin]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_dwithinuncached" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_dwithin_uncached]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_equals" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_Equals]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_expand" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_expand]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_geomfromgml" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geom_from_gml]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_intersects" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_Intersects]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_linecrossingdirection" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_LineCrossingDirection]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_longestline" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_longestline2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_maxdistance" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_maxdistance2d_linestring]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_orderingequals" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_same]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_overlaps" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[overlaps]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_pointoutside" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_point_outside]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_touches" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[touches]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_voronoi" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_Voronoi]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_within" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[SELECT public._ST_Contains($2,$1)]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="addauth" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: auth_token - Adds an authorization token to be used in the current transaction.]]></comment>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	lockid alias for $1;
	okay boolean;
	myrec record;
BEGIN
	-- check to see if table exists
	--  if not, CREATE TEMP TABLE mylock (transid xid, lockcode text)
	okay := 'f';
	FOR myrec IN SELECT * FROM pg_class WHERE relname = 'temp_lock_have_table' LOOP
		okay := 't';
	END LOOP;
	IF (okay <> 't') THEN
		CREATE TEMP TABLE temp_lock_have_table (transid xid, lockcode text);
			-- this will only work from pgsql7.4 up
			-- ON COMMIT DELETE ROWS;
	END IF;

	--  INSERT INTO mylock VALUES ( $1)
--	EXECUTE 'INSERT INTO temp_lock_have_table VALUES ( '||
--		quote_literal(getTransactionID()) || ',' ||
--		quote_literal(lockid) ||')';

	INSERT INTO temp_lock_have_table VALUES (getTransactionID(), lockid);

	RETURN true::boolean;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="addgeometrycolumn" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: catalog_name, schema_name, table_name, column_name, srid, type, dimension, use_typmod=true - Adds a geometry column to an existing table.]]></comment>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	rec RECORD;
	sr varchar;
	real_schema name;
	sql text;
	new_srid integer;

BEGIN

	-- Verify geometry type
	IF (postgis_type_name(new_type,new_dim) IS NULL )
	THEN
		RAISE EXCEPTION 'Invalid type name "%(%)" - valid ones are:
	POINT, MULTIPOINT,
	LINESTRING, MULTILINESTRING,
	POLYGON, MULTIPOLYGON,
	CIRCULARSTRING, COMPOUNDCURVE, MULTICURVE,
	CURVEPOLYGON, MULTISURFACE,
	GEOMETRY, GEOMETRYCOLLECTION,
	POINTM, MULTIPOINTM,
	LINESTRINGM, MULTILINESTRINGM,
	POLYGONM, MULTIPOLYGONM,
	CIRCULARSTRINGM, COMPOUNDCURVEM, MULTICURVEM
	CURVEPOLYGONM, MULTISURFACEM, TRIANGLE, TRIANGLEM,
	POLYHEDRALSURFACE, POLYHEDRALSURFACEM, TIN, TINM
	or GEOMETRYCOLLECTIONM', new_type, new_dim;
		RETURN 'fail';
	END IF;

	-- Verify dimension
	IF ( (new_dim >4) OR (new_dim <2) ) THEN
		RAISE EXCEPTION 'invalid dimension';
		RETURN 'fail';
	END IF;

	IF ( (new_type LIKE '%M') AND (new_dim!=3) ) THEN
		RAISE EXCEPTION 'TypeM needs 3 dimensions';
		RETURN 'fail';
	END IF;

	-- Verify SRID
	IF ( new_srid_in > 0 ) THEN
		IF new_srid_in > 998999 THEN
			RAISE EXCEPTION 'AddGeometryColumn() - SRID must be <= %', 998999;
		END IF;
		new_srid := new_srid_in;
		SELECT SRID INTO sr FROM spatial_ref_sys WHERE SRID = new_srid;
		IF NOT FOUND THEN
			RAISE EXCEPTION 'AddGeometryColumn() - invalid SRID';
			RETURN 'fail';
		END IF;
	ELSE
		new_srid := public.ST_SRID('POINT EMPTY'::public.geometry);
		IF ( new_srid_in != new_srid ) THEN
			RAISE NOTICE 'SRID value % converted to the officially unknown SRID value %', new_srid_in, new_srid;
		END IF;
	END IF;

	-- Verify schema
	IF ( schema_name IS NOT NULL AND schema_name != '' ) THEN
		sql := 'SELECT nspname FROM pg_namespace ' ||
			'WHERE text(nspname) = ' || quote_literal(schema_name) ||
			'LIMIT 1';
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Schema % is not a valid schemaname', quote_literal(schema_name);
			RETURN 'fail';
		END IF;
	END IF;

	IF ( real_schema IS NULL ) THEN
		RAISE DEBUG 'Detecting schema';
		sql := 'SELECT n.nspname AS schemaname ' ||
			'FROM pg_catalog.pg_class c ' ||
			  'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace ' ||
			'WHERE c.relkind = ' || quote_literal('r') ||
			' AND n.nspname NOT IN (' || quote_literal('pg_catalog') || ', ' || quote_literal('pg_toast') || ')' ||
			' AND pg_catalog.pg_table_is_visible(c.oid)' ||
			' AND c.relname = ' || quote_literal(table_name);
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Table % does not occur in the search_path', quote_literal(table_name);
			RETURN 'fail';
		END IF;
	END IF;

	-- Add geometry column to table
	IF use_typmod THEN
	     sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD COLUMN ' || quote_ident(column_name) ||
            ' geometry(' || public.postgis_type_name(new_type, new_dim) || ', ' || new_srid::text || ')';
        RAISE DEBUG '%', sql;
	ELSE
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD COLUMN ' || quote_ident(column_name) ||
            ' geometry ';
        RAISE DEBUG '%', sql;
    END IF;
	EXECUTE sql;

	IF NOT use_typmod THEN
        -- Add table CHECKs
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD CONSTRAINT '
            || quote_ident('enforce_srid_' || column_name)
            || ' CHECK (st_srid(' || quote_ident(column_name) ||
            ') = ' || new_srid::text || ')' ;
        RAISE DEBUG '%', sql;
        EXECUTE sql;

        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD CONSTRAINT '
            || quote_ident('enforce_dims_' || column_name)
            || ' CHECK (st_ndims(' || quote_ident(column_name) ||
            ') = ' || new_dim::text || ')' ;
        RAISE DEBUG '%', sql;
        EXECUTE sql;

        IF ( NOT (new_type = 'GEOMETRY')) THEN
            sql := 'ALTER TABLE ' ||
                quote_ident(real_schema) || '.' || quote_ident(table_name) || ' ADD CONSTRAINT ' ||
                quote_ident('enforce_geotype_' || column_name) ||
                ' CHECK (GeometryType(' ||
                quote_ident(column_name) || ')=' ||
                quote_literal(new_type) || ' OR (' ||
                quote_ident(column_name) || ') is null)';
            RAISE DEBUG '%', sql;
            EXECUTE sql;
        END IF;
    END IF;

	RETURN
		real_schema || '.' ||
		table_name || '.' || column_name ||
		' SRID:' || new_srid::text ||
		' TYPE:' || new_type ||
		' DIMS:' || new_dim::text || ' ';
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box" returnType="box" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_to_BOX]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box2d" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[BOX3D_to_BOX2D]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box2d_in" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[BOX2D_in]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box2d_out" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[BOX2D_out]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box2df_in" returnType="box2df" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[box2df_in]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box2df_out" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[box2df_out]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box3d" returnType="box3d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[BOX2D_to_BOX3D]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box3d_in" returnType="box3d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[BOX3D_in]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box3d_out" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[BOX3D_out]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box3dtobox" returnType="box" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[BOX3D_to_BOX]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="bytea" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_to_bytea]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="checkauth" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_table_name, a_key_column_name - Creates a trigger on a table to prevent/allow updates and deletes of rows based on authorization token.]]></comment>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	schema text;
BEGIN
	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	if ( $1 != '' ) THEN
		schema = $1;
	ELSE
		SELECT current_schema() into schema;
	END IF;

	-- TODO: check for an already existing trigger ?

	EXECUTE 'CREATE TRIGGER check_auth BEFORE UPDATE OR DELETE ON '
		|| quote_ident(schema) || '.' || quote_ident($2)
		||' FOR EACH ROW EXECUTE PROCEDURE CheckAuthTrigger('
		|| quote_literal($3) || ')';

	RETURN 0;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="checkauthtrigger" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[check_authorization]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="column_exists" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
    -- does the requested table.column exist in schema?
SELECT EXISTS
           (SELECT NULL
            FROM information_schema.columns
            WHERE table_name = ptable
              AND column_name = pcolumn
           );
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="contains_2d" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_contains_box2df_geom_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="difference" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[difference]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="disablelongtransactions" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Disables long transaction support.]]></comment>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	rec RECORD;

BEGIN

	--
	-- Drop all triggers applied by CheckAuth()
	--
	FOR rec IN
		SELECT c.relname, t.tgname, t.tgargs FROM pg_trigger t, pg_class c, pg_proc p
		WHERE p.proname = 'checkauthtrigger' and t.tgfoid = p.oid and t.tgrelid = c.oid
	LOOP
		EXECUTE 'DROP TRIGGER ' || quote_ident(rec.tgname) ||
			' ON ' || quote_ident(rec.relname);
	END LOOP;

	--
	-- Drop the authorization_table table
	--
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table' LOOP
		DROP TABLE authorization_table;
	END LOOP;

	--
	-- Drop the authorized_tables view
	--
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables' LOOP
		DROP VIEW authorized_tables;
	END LOOP;

	RETURN 'Long transactions support disabled';
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="dmetaphone" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[dmetaphone]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="dmetaphone_alt" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[dmetaphone_alt]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dropgeometrycolumn" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: catalog_name, schema_name, table_name, column_name - Removes a geometry column from a spatial table.]]></comment>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	ret text;
BEGIN
	SELECT public.DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dropgeometrytable" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: catalog_name, schema_name, table_name - Drops a table and all its references in geometry_columns.]]></comment>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	real_schema name;

BEGIN

	IF ( schema_name = '' ) THEN
		SELECT current_schema() into real_schema;
	ELSE
		real_schema = schema_name;
	END IF;

	-- TODO: Should we warn if table doesn't exist probably instead just saying dropped
	-- Remove table
	EXECUTE 'DROP TABLE IF EXISTS '
		|| quote_ident(real_schema) || '.' ||
		quote_ident(table_name) || ' RESTRICT';

	RETURN
		real_schema || '.' ||
		table_name ||' dropped.';

END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="enablelongtransactions" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Enables long transaction support.]]></comment>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	"query" text;
	exists bool;
	rec RECORD;

BEGIN

	exists = 'f';
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table'
	LOOP
		exists = 't';
	END LOOP;

	IF NOT exists
	THEN
		"query" = 'CREATE TABLE authorization_table (
			toid oid, -- table oid
			rid text, -- row id
			expires timestamp,
			authid text
		)';
		EXECUTE "query";
	END IF;

	exists = 'f';
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		exists = 't';
	END LOOP;

	IF NOT exists THEN
		"query" = 'CREATE VIEW authorized_tables AS ' ||
			'SELECT ' ||
			'n.nspname as schema, ' ||
			'c.relname as table, trim(' ||
			quote_literal(chr(92) || '000') ||
			' from t.tgargs) as id_column ' ||
			'FROM pg_trigger t, pg_class c, pg_proc p ' ||
			', pg_namespace n ' ||
			'WHERE p.proname = ' || quote_literal('checkauthtrigger') ||
			' AND c.relnamespace = n.oid' ||
			' AND t.tgfoid = p.oid and t.tgrelid = c.oid';
		EXECUTE "query";
	END IF;

	RETURN 'Long transactions support enabled';
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="equals" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_Equals]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="find_srid" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_schema_name, a_table_name, a_geomfield_name - Returns the SRID defined for a geometry column.]]></comment>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	schem varchar =  $1;
	tabl varchar = $2;
	sr int4;
BEGIN
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and strpos(tabl,'.') > 0 ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	END IF;

	select SRID into sr from public.geometry_columns where (f_table_schema = schem or schem = '') and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - could not find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase mismatch?';
	END IF;
	return sr;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geog_brin_inclusion_add_value" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geog_brin_inclusion_add_value]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_enforce_typmod]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_analyze" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_analyze_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_cmp" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_cmp]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_distance_knn" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_distance_knn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_eq" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_eq]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_ge" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_ge]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_compress" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_compress]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_consistent" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_consistent]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_decompress" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_decompress]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_distance" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_geog_distance]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_penalty" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_penalty]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_picksplit" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_picksplit]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_same" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_same]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_union" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_union]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_gt" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_gt]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_in" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_in]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_le" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_le]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_lt" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_lt]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_out" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_out]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_overlaps" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_overlaps]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_recv" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_recv]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_send" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_send]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_spgist_choose_nd" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_choose_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_spgist_compress_nd" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_compress_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_spgist_config_nd" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_config_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_spgist_inner_consistent_nd" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_inner_consistent_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_spgist_leaf_consistent_nd" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_leaf_consistent_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_spgist_picksplit_nd" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_picksplit_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_typmod_in" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_typmod_in]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_typmod_out" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[postgis_typmod_out]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geom2d_brin_inclusion_add_value" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geom2d_brin_inclusion_add_value]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geom3d_brin_inclusion_add_value" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geom3d_brin_inclusion_add_value]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geom4d_brin_inclusion_add_value" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geom4d_brin_inclusion_add_value]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geometry_from_geography]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_above" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_above_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_analyze" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_analyze_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_below" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_below_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_cmp" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[lwgeom_cmp]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_contained_3d" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_contained_3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_contains" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_contains_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_contains_3d" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_contains_3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_contains_nd" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_contains]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_distance_box" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_distance_box_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_distance_centroid" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_Distance]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_distance_centroid_nd" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_distance_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_distance_cpa" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_DistanceCPA]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_eq" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[lwgeom_eq]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_ge" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[lwgeom_ge]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_compress_2d" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_compress_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_compress_nd" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_compress]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_consistent_2d" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_consistent_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_consistent_nd" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_consistent]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_decompress_2d" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_decompress_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_decompress_nd" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_decompress]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_distance_2d" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_distance_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_distance_nd" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_distance]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_penalty_2d" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_penalty_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_penalty_nd" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_penalty]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_picksplit_2d" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_picksplit_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_picksplit_nd" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_picksplit]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_same_2d" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_same_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_same_nd" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_same]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_union_2d" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_union_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_union_nd" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_union]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_gt" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[lwgeom_gt]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_hash" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[lwgeom_hash]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_in" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_in]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_le" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[lwgeom_le]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_left" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_left_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_lt" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[lwgeom_lt]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_out" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_out]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_overabove" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_overabove_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_overbelow" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_overbelow_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_overlaps" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_overlaps_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_overlaps_3d" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_overlaps_3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_overlaps_nd" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_overlaps]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_overleft" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_overleft_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_overright" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_overright_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_recv" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_recv]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_right" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_right_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_same" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_same_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_same_3d" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_same_3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_same_nd" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_same]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_send" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_send]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_sortsupport" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[lwgeom_sortsupport]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_choose_2d" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_choose_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_choose_3d" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_choose_3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_choose_nd" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_choose_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_compress_2d" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_compress_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_compress_3d" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_compress_3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_compress_nd" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_compress_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_config_2d" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_config_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_config_3d" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_config_3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_config_nd" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_config_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_inner_consistent_2d" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_inner_consistent_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_inner_consistent_3d" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_inner_consistent_3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_inner_consistent_nd" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_inner_consistent_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_leaf_consistent_2d" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_leaf_consistent_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_leaf_consistent_3d" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_leaf_consistent_3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_leaf_consistent_nd" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_leaf_consistent_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_picksplit_2d" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_picksplit_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_picksplit_3d" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_picksplit_3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_picksplit_nd" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_spgist_picksplit_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_typmod_in" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geometry_typmod_in]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_typmod_out" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[postgis_typmod_out]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_within" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_within_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_within_nd" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_within]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometrytype" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_getTYPE]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geomfromewkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOMFromEWKB]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geomfromewkt" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[parse_WKT_lwgeom]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="get_proj4_from_srid" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
	BEGIN
	RETURN proj4text::text FROM public.spatial_ref_sys WHERE srid= $1;
	END;
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gettransactionid" returnType="xid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[getTransactionID]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gidx_in" returnType="gidx" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gidx_in]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gidx_out" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gidx_out]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gin_extract_query_trgm" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gin_extract_query_trgm]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gin_extract_value_trgm" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gin_extract_value_trgm]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gin_trgm_consistent" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gin_trgm_consistent]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gin_trgm_triconsistent" returnType="&quot;char&quot;" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gin_trgm_triconsistent]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gserialized_gist_joinsel_2d" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_joinsel_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gserialized_gist_joinsel_nd" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_joinsel_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gserialized_gist_sel_2d" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_sel_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gserialized_gist_sel_nd" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gist_sel_nd]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gtrgm_compress" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gtrgm_compress]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gtrgm_consistent" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gtrgm_consistent]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gtrgm_decompress" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gtrgm_decompress]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gtrgm_distance" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gtrgm_distance]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gtrgm_in" returnType="gtrgm" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gtrgm_in]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gtrgm_options" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gtrgm_options]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gtrgm_out" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gtrgm_out]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gtrgm_penalty" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gtrgm_penalty]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gtrgm_picksplit" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gtrgm_picksplit]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gtrgm_same" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gtrgm_same]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gtrgm_union" returnType="gtrgm" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gtrgm_union]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="is_contained_2d" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[SELECT $2 OPERATOR(public.~) $1;]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="json" returnType="json" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geometry_to_json]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="jsonb" returnType="jsonb" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geometry_to_jsonb]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="levenshtein" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[levenshtein]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="levenshtein_less_equal" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[levenshtein_less_equal]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="lockrow" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	myschema alias for $1;
	mytable alias for $2;
	myrid   alias for $3;
	authid alias for $4;
	expires alias for $5;
	ret int;
	mytoid oid;
	myrec RECORD;

BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	EXECUTE 'DELETE FROM authorization_table WHERE expires < now()';

	SELECT c.oid INTO mytoid FROM pg_class c, pg_namespace n
		WHERE c.relname = mytable
		AND c.relnamespace = n.oid
		AND n.nspname = myschema;

	-- RAISE NOTICE 'toid: %', mytoid;

	FOR myrec IN SELECT * FROM authorization_table WHERE
		toid = mytoid AND rid = myrid
	LOOP
		IF myrec.authid != authid THEN
			RETURN 0;
		ELSE
			RETURN 1;
		END IF;
	END LOOP;

	EXECUTE 'INSERT INTO authorization_table VALUES ('||
		quote_literal(mytoid::text)||','||quote_literal(myrid)||
		','||quote_literal(expires::text)||
		','||quote_literal(authid) ||')';

	GET DIAGNOSTICS ret = ROW_COUNT;

	RETURN ret;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="longtransactionsenabled" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="metaphone" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[metaphone]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="overlaps_2d" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[SELECT $2 OPERATOR(public.&&) $1;]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="overlaps_geog" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gidx_geog_overlaps]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="overlaps_nd" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[gserialized_gidx_geom_overlaps]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="path" returnType="path" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geometry_to_path]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asgeobuf_finalfn" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[pgis_asgeobuf_finalfn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asgeobuf_transfn" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[pgis_asgeobuf_transfn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asmvt_combinefn" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[pgis_asmvt_combinefn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asmvt_deserialfn" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[pgis_asmvt_deserialfn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asmvt_finalfn" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[pgis_asmvt_finalfn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asmvt_serialfn" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[pgis_asmvt_serialfn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asmvt_transfn" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[pgis_asmvt_transfn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_accum_transfn" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[pgis_geometry_accum_transfn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_clusterintersecting_finalfn" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[pgis_geometry_clusterintersecting_finalfn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_clusterwithin_finalfn" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[pgis_geometry_clusterwithin_finalfn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_collect_finalfn" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[pgis_geometry_collect_finalfn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_makeline_finalfn" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[pgis_geometry_makeline_finalfn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_polygonize_finalfn" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[pgis_geometry_polygonize_finalfn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_union_finalfn" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[pgis_geometry_union_finalfn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="point" returnType="point" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geometry_to_point]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="polygon" returnType="polygon" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geometry_to_polygon]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="populate_geometry_columns" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: relation_oid, use_typmod=true - Ensures geometry columns are defined with type modifiers or have appropriate spatial constraints.]]></comment>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	inserted    integer;
	oldcount    integer;
	probed      integer;
	stale       integer;
	gcs         RECORD;
	gc          RECORD;
	gsrid       integer;
	gndims      integer;
	gtype       text;
	query       text;
	gc_is_valid boolean;

BEGIN
	SELECT count(*) INTO oldcount FROM public.geometry_columns;
	inserted := 0;

	-- Count the number of geometry columns in all tables and views
	SELECT count(DISTINCT c.oid) INTO probed
	FROM pg_class c,
		 pg_attribute a,
		 pg_type t,
		 pg_namespace n
	WHERE c.relkind IN('r','v','f')
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%' AND c.relname != 'raster_columns' ;

	-- Iterate through all non-dropped geometry columns
	RAISE DEBUG 'Processing Tables.....';

	FOR gcs IN
	SELECT DISTINCT ON (c.oid) c.oid, n.nspname, c.relname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind IN( 'r', 'f')
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%' AND c.relname != 'raster_columns'
	LOOP

		inserted := inserted + public.populate_geometry_columns(gcs.oid, use_typmod);
	END LOOP;

	IF oldcount > inserted THEN
	    stale = oldcount-inserted;
	ELSE
	    stale = 0;
	END IF;

	RETURN 'probed:' ||probed|| ' inserted:'||inserted;
END

]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_addbbox" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Add bounding box to the geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_addBBOX]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="postgis_cache_bbox" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[cache_bbox]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="postgis_constraint_dims" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT  replace(split_part(s.consrc, ' = ', 2), ')', '')::integer
		 FROM pg_class c, pg_namespace n, pg_attribute a
		 , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
		    FROM pg_constraint) AS s
		 WHERE n.nspname = $1
		 AND c.relname = $2
		 AND a.attname = $3
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%ndims(% = %';
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="postgis_constraint_srid" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT replace(replace(split_part(s.consrc, ' = ', 2), ')', ''), '(', '')::integer
		 FROM pg_class c, pg_namespace n, pg_attribute a
		 , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
		    FROM pg_constraint) AS s
		 WHERE n.nspname = $1
		 AND c.relname = $2
		 AND a.attname = $3
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%srid(% = %';
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="postgis_constraint_type" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT  replace(split_part(s.consrc, '''', 2), ')', '')::varchar
		 FROM pg_class c, pg_namespace n, pg_attribute a
		 , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
		    FROM pg_constraint) AS s
		 WHERE n.nspname = $1
		 AND c.relname = $2
		 AND a.attname = $3
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%geometrytype(% = %';
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_dropbbox" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Drop the bounding box cache from the geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_dropBBOX]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="postgis_extensions_upgrade" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Packages and upgrades postgis extensions (e.g. postgis_raster,postgis_topology, postgis_sfcgal) to latest available version.]]></comment>
         <definition language="PLPGSQL"><![CDATA[
DECLARE rec record; sql text; var_schema text;
BEGIN

	FOR rec IN
		SELECT name, default_version, installed_version
		FROM pg_catalog.pg_available_extensions
		WHERE name IN (
			'postgis',
			'postgis_raster',
			'postgis_sfcgal',
			'postgis_topology',
			'postgis_tiger_geocoder'
		)
		ORDER BY length(name) -- this is to make sure 'postgis' is first !
	LOOP
		IF rec.installed_version IS NULL THEN
			-- If the support installed by available extension
			-- is found unpackaged, we package it
			IF
				 -- PostGIS is always available (this function is part of it)
				 rec.name = 'postgis'

				 -- PostGIS raster is available if type 'raster' exists
				 OR ( rec.name = 'postgis_raster' AND EXISTS (
							SELECT 1 FROM pg_catalog.pg_type
							WHERE typname = 'raster' ) )

				 -- PostGIS SFCGAL is availble if
				 -- 'postgis_sfcgal_version' function exists
				 OR ( rec.name = 'postgis_sfcgal' AND EXISTS (
							SELECT 1 FROM pg_catalog.pg_proc
							WHERE proname = 'postgis_sfcgal_version' ) )

				 -- PostGIS Topology is available if
				 -- 'topology.topology' table exists
				 -- NOTE: watch out for https://trac.osgeo.org/postgis/ticket/2503
				 OR ( rec.name = 'postgis_topology' AND EXISTS (
							SELECT 1 FROM pg_catalog.pg_class c
							JOIN pg_catalog.pg_namespace n ON (c.relnamespace = n.oid )
							WHERE n.nspname = 'topology' AND c.relname = 'topology') )

				 OR ( rec.name = 'postgis_tiger_geocoder' AND EXISTS (
							SELECT 1 FROM pg_catalog.pg_class c
							JOIN pg_catalog.pg_namespace n ON (c.relnamespace = n.oid )
							WHERE n.nspname = 'tiger' AND c.relname = 'geocode_settings') )
			THEN
				--force install in same schema as postgis only if postgis extension is installed
				IF rec.name NOT IN('postgis', 'postgis_topology', 'postgis_tiger_geocoder') AND EXISTS (SELECT 1 FROM pg_catalog.pg_extension WHERE extname = 'postgis') THEN
					sql = 'CREATE EXTENSION ' || rec.name || ' FROM unpackaged SCHEMA '
					|| quote_ident( (SELECT ns.nspname FROM pg_catalog.pg_extension AS e INNER JOIN pg_catalog.pg_namespace AS ns ON e.extnamespace = ns.oid WHERE extname = 'postgis')) || ';';
				ELSE
					sql = 'CREATE EXTENSION ' || rec.name || ' FROM unpackaged;';
				END IF;
				RAISE NOTICE 'Packaging extension %', rec.name;
				RAISE DEBUG '%', sql;
				EXECUTE sql;
			ELSE
				RAISE NOTICE 'Extension % is not available or not packagable for some reason', rec.name;
			END IF;
		ELSIF rec.default_version != rec.installed_version
		THEN
			sql = 'ALTER EXTENSION ' || rec.name || ' UPDATE TO ' ||
						quote_ident(rec.default_version)   || ';';
			RAISE NOTICE 'Updating extension % from % to %',
				rec.name, rec.installed_version, rec.default_version;
			RAISE DEBUG '%', sql;
			EXECUTE sql;
		ELSIF (rec.default_version = rec.installed_version AND rec.installed_version ILIKE '%dev') OR
			(public._postgis_pgsql_version() != public._postgis_scripts_pgsql_version())
		THEN
			-- we need to upgrade to next and back
			RAISE NOTICE 'Updating extension % %',
				rec.name, rec.installed_version;
			sql = 'ALTER EXTENSION ' || rec.name || ' UPDATE TO ' ||
						quote_ident(rec.default_version || 'next')   || ';';
			RAISE DEBUG '%', sql;
			EXECUTE sql;
			sql = 'ALTER EXTENSION ' || rec.name || ' UPDATE TO ' ||
						quote_ident(rec.default_version)   || ';';
			RAISE DEBUG '%', sql;
			EXECUTE sql;
		END IF;

	END LOOP;

	RETURN 'Upgrade completed, run SELECT postgis_full_version(); for details';

END
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_full_version" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Reports full postgis version and build configuration infos.]]></comment>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	libver text;
	librev text;
	projver text;
	geosver text;
	sfcgalver text;
	gdalver text := NULL;
	libxmlver text;
	liblwgeomver text;
	dbproc text;
	relproc text;
	fullver text;
	rast_lib_ver text := NULL;
	rast_scr_ver text := NULL;
	topo_scr_ver text := NULL;
	json_lib_ver text;
	protobuf_lib_ver text;
	wagyu_lib_ver text;
	sfcgal_lib_ver text;
	sfcgal_scr_ver text;
	pgsql_scr_ver text;
	pgsql_ver text;
	core_is_extension bool;
BEGIN
	SELECT public.postgis_lib_version() INTO libver;
	SELECT public.postgis_svn_version() INTO librev;
	SELECT public.postgis_proj_version() INTO projver;
	SELECT public.postgis_geos_version() INTO geosver;
	SELECT public.postgis_libjson_version() INTO json_lib_ver;
	SELECT public.postgis_libprotobuf_version() INTO protobuf_lib_ver;
	SELECT public.postgis_wagyu_version() INTO wagyu_lib_ver;
	SELECT public._postgis_scripts_pgsql_version() INTO pgsql_scr_ver;
	SELECT public._postgis_pgsql_version() INTO pgsql_ver;
	BEGIN
		SELECT public.postgis_gdal_version() INTO gdalver;
	EXCEPTION
		WHEN undefined_function THEN
			RAISE DEBUG 'Function postgis_gdal_version() not found.  Is raster support enabled and rtpostgis.sql installed?';
	END;
	BEGIN
		SELECT public.postgis_sfcgal_version() INTO sfcgalver;
		BEGIN
			SELECT public.postgis_sfcgal_scripts_installed() INTO sfcgal_scr_ver;
		EXCEPTION
			WHEN undefined_function THEN
				sfcgal_scr_ver := 'missing';
		END;
	EXCEPTION
		WHEN undefined_function THEN
			RAISE DEBUG 'Function postgis_sfcgal_scripts_installed() not found. Is sfcgal support enabled and sfcgal.sql installed?';
	END;
	SELECT public.postgis_liblwgeom_version() INTO liblwgeomver;
	SELECT public.postgis_libxml_version() INTO libxmlver;
	SELECT public.postgis_scripts_installed() INTO dbproc;
	SELECT public.postgis_scripts_released() INTO relproc;
	SELECT public.postgis_svn_version() INTO librev;
	BEGIN
		SELECT topology.postgis_topology_scripts_installed() INTO topo_scr_ver;
	EXCEPTION
		WHEN undefined_function OR invalid_schema_name THEN
			RAISE DEBUG 'Function postgis_topology_scripts_installed() not found. Is topology support enabled and topology.sql installed?';
		WHEN insufficient_privilege THEN
			RAISE NOTICE 'Topology support cannot be inspected. Is current user granted USAGE on schema "topology" ?';
		WHEN OTHERS THEN
			RAISE NOTICE 'Function postgis_topology_scripts_installed() could not be called: % (%)', SQLERRM, SQLSTATE;
	END;

	BEGIN
		SELECT postgis_raster_scripts_installed() INTO rast_scr_ver;
	EXCEPTION
		WHEN undefined_function THEN
			RAISE DEBUG 'Function postgis_raster_scripts_installed() not found. Is raster support enabled and rtpostgis.sql installed?';
		WHEN OTHERS THEN
			RAISE NOTICE 'Function postgis_raster_scripts_installed() could not be called: % (%)', SQLERRM, SQLSTATE;
	END;

	BEGIN
		SELECT public.postgis_raster_lib_version() INTO rast_lib_ver;
	EXCEPTION
		WHEN undefined_function THEN
			RAISE DEBUG 'Function postgis_raster_lib_version() not found. Is raster support enabled and rtpostgis.sql installed?';
		WHEN OTHERS THEN
			RAISE NOTICE 'Function postgis_raster_lib_version() could not be called: % (%)', SQLERRM, SQLSTATE;
	END;

	fullver = 'POSTGIS="' || libver;

	IF  librev IS NOT NULL THEN
		fullver = fullver || ' ' || librev;
	END IF;

	fullver = fullver || '"';

	IF EXISTS (
		SELECT * FROM pg_catalog.pg_extension
		WHERE extname = 'postgis')
	THEN
			fullver = fullver || ' [EXTENSION]';
			core_is_extension := true;
	ELSE
			core_is_extension := false;
	END IF;

	IF liblwgeomver != relproc THEN
		fullver = fullver || ' (liblwgeom version mismatch: "' || liblwgeomver || '")';
	END IF;

	fullver = fullver || ' PGSQL="' || pgsql_scr_ver || '"';
	IF pgsql_scr_ver != pgsql_ver THEN
		fullver = fullver || ' (procs need upgrade for use with PostgreSQL "' || pgsql_ver || '")';
	END IF;

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS="' || geosver || '"';
	END IF;

	IF  sfcgalver IS NOT NULL THEN
		fullver = fullver || ' SFCGAL="' || sfcgalver || '"';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ="' || projver || '"';
	END IF;

	IF  gdalver IS NOT NULL THEN
		fullver = fullver || ' GDAL="' || gdalver || '"';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML="' || libxmlver || '"';
	END IF;

	IF json_lib_ver IS NOT NULL THEN
		fullver = fullver || ' LIBJSON="' || json_lib_ver || '"';
	END IF;

	IF protobuf_lib_ver IS NOT NULL THEN
		fullver = fullver || ' LIBPROTOBUF="' || protobuf_lib_ver || '"';
	END IF;

	IF wagyu_lib_ver IS NOT NULL THEN
		fullver = fullver || ' WAGYU="' || wagyu_lib_ver || '"';
	END IF;

	IF dbproc != relproc THEN
		fullver = fullver || ' (core procs from "' || dbproc || '" need upgrade)';
	END IF;

	IF topo_scr_ver IS NOT NULL THEN
		fullver = fullver || ' TOPOLOGY';
		IF topo_scr_ver != relproc THEN
			fullver = fullver || ' (topology procs from "' || topo_scr_ver || '" need upgrade)';
		END IF;
		IF core_is_extension AND NOT EXISTS (
			SELECT * FROM pg_catalog.pg_extension
			WHERE extname = 'postgis_topology')
		THEN
				fullver = fullver || ' [UNPACKAGED!]';
		END IF;
	END IF;

	IF rast_lib_ver IS NOT NULL THEN
		fullver = fullver || ' RASTER';
		IF rast_lib_ver != relproc THEN
			fullver = fullver || ' (raster lib from "' || rast_lib_ver || '" need upgrade)';
		END IF;
		IF core_is_extension AND NOT EXISTS (
			SELECT * FROM pg_catalog.pg_extension
			WHERE extname = 'postgis_raster')
		THEN
				fullver = fullver || ' [UNPACKAGED!]';
		END IF;
	END IF;

	IF rast_scr_ver IS NOT NULL AND rast_scr_ver != relproc THEN
		fullver = fullver || ' (raster procs from "' || rast_scr_ver || '" need upgrade)';
	END IF;

	IF sfcgal_scr_ver IS NOT NULL AND sfcgal_scr_ver != relproc THEN
		fullver = fullver || ' (sfcgal procs from "' || sfcgal_scr_ver || '" need upgrade)';
	END IF;

	RETURN fullver;
END
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_geos_noop" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[GEOSnoop]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_geos_version" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns the version number of the GEOS library.]]></comment>
         <definition language="C"><![CDATA[postgis_geos_version]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_getbbox" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_to_BOX2DF]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_hasbbox" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns TRUE if the bbox of this geometry is cached, FALSE otherwise.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_hasBBOX]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="postgis_index_supportfn" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[postgis_index_supportfn]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_lib_build_date" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns build date of the PostGIS library.]]></comment>
         <definition language="C"><![CDATA[postgis_lib_build_date]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_lib_version" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns the version number of the PostGIS library.]]></comment>
         <definition language="C"><![CDATA[postgis_lib_version]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_libjson_version" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[postgis_libjson_version]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_liblwgeom_version" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns the version number of the liblwgeom library. This should match the version of PostGIS.]]></comment>
         <definition language="C"><![CDATA[postgis_liblwgeom_version]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_libprotobuf_version" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[postgis_libprotobuf_version]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_libxml_version" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns the version number of the libxml2 library.]]></comment>
         <definition language="C"><![CDATA[postgis_libxml_version]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_noop" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_noop]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_proj_version" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns the version number of the PROJ4 library.]]></comment>
         <definition language="C"><![CDATA[postgis_proj_version]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_scripts_build_date" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns build date of the PostGIS scripts.]]></comment>
         <definition language="SQL"><![CDATA[SELECT '2020-11-21 07:57:14'::text AS version]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_scripts_installed" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns version of the postgis scripts installed in this database.]]></comment>
         <definition language="SQL"><![CDATA[ SELECT trim('3.0.3'::text || $rev$ 6660953 $rev$) AS version ]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_scripts_released" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns the version number of the postgis.sql script released with the installed postgis lib.]]></comment>
         <definition language="C"><![CDATA[postgis_scripts_released]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_svn_version" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[postgis_svn_version]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_transform_geometry" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[transform_geom]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_type_name" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN $3 THEN new_name ELSE old_name END As geomname
	FROM
	( VALUES
			('GEOMETRY', 'Geometry', 2),
			('GEOMETRY', 'GeometryZ', 3),
			('GEOMETRYM', 'GeometryM', 3),
			('GEOMETRY', 'GeometryZM', 4),

			('GEOMETRYCOLLECTION', 'GeometryCollection', 2),
			('GEOMETRYCOLLECTION', 'GeometryCollectionZ', 3),
			('GEOMETRYCOLLECTIONM', 'GeometryCollectionM', 3),
			('GEOMETRYCOLLECTION', 'GeometryCollectionZM', 4),

			('POINT', 'Point', 2),
			('POINT', 'PointZ', 3),
			('POINTM','PointM', 3),
			('POINT', 'PointZM', 4),

			('MULTIPOINT','MultiPoint', 2),
			('MULTIPOINT','MultiPointZ', 3),
			('MULTIPOINTM','MultiPointM', 3),
			('MULTIPOINT','MultiPointZM', 4),

			('POLYGON', 'Polygon', 2),
			('POLYGON', 'PolygonZ', 3),
			('POLYGONM', 'PolygonM', 3),
			('POLYGON', 'PolygonZM', 4),

			('MULTIPOLYGON', 'MultiPolygon', 2),
			('MULTIPOLYGON', 'MultiPolygonZ', 3),
			('MULTIPOLYGONM', 'MultiPolygonM', 3),
			('MULTIPOLYGON', 'MultiPolygonZM', 4),

			('MULTILINESTRING', 'MultiLineString', 2),
			('MULTILINESTRING', 'MultiLineStringZ', 3),
			('MULTILINESTRINGM', 'MultiLineStringM', 3),
			('MULTILINESTRING', 'MultiLineStringZM', 4),

			('LINESTRING', 'LineString', 2),
			('LINESTRING', 'LineStringZ', 3),
			('LINESTRINGM', 'LineStringM', 3),
			('LINESTRING', 'LineStringZM', 4),

			('CIRCULARSTRING', 'CircularString', 2),
			('CIRCULARSTRING', 'CircularStringZ', 3),
			('CIRCULARSTRINGM', 'CircularStringM' ,3),
			('CIRCULARSTRING', 'CircularStringZM', 4),

			('COMPOUNDCURVE', 'CompoundCurve', 2),
			('COMPOUNDCURVE', 'CompoundCurveZ', 3),
			('COMPOUNDCURVEM', 'CompoundCurveM', 3),
			('COMPOUNDCURVE', 'CompoundCurveZM', 4),

			('CURVEPOLYGON', 'CurvePolygon', 2),
			('CURVEPOLYGON', 'CurvePolygonZ', 3),
			('CURVEPOLYGONM', 'CurvePolygonM', 3),
			('CURVEPOLYGON', 'CurvePolygonZM', 4),

			('MULTICURVE', 'MultiCurve', 2),
			('MULTICURVE', 'MultiCurveZ', 3),
			('MULTICURVEM', 'MultiCurveM', 3),
			('MULTICURVE', 'MultiCurveZM', 4),

			('MULTISURFACE', 'MultiSurface', 2),
			('MULTISURFACE', 'MultiSurfaceZ', 3),
			('MULTISURFACEM', 'MultiSurfaceM', 3),
			('MULTISURFACE', 'MultiSurfaceZM', 4),

			('POLYHEDRALSURFACE', 'PolyhedralSurface', 2),
			('POLYHEDRALSURFACE', 'PolyhedralSurfaceZ', 3),
			('POLYHEDRALSURFACEM', 'PolyhedralSurfaceM', 3),
			('POLYHEDRALSURFACE', 'PolyhedralSurfaceZM', 4),

			('TRIANGLE', 'Triangle', 2),
			('TRIANGLE', 'TriangleZ', 3),
			('TRIANGLEM', 'TriangleM', 3),
			('TRIANGLE', 'TriangleZM', 4),

			('TIN', 'Tin', 2),
			('TIN', 'TinZ', 3),
			('TINM', 'TinM', 3),
			('TIN', 'TinZM', 4) )
			 As g(old_name, new_name, coord_dimension)
	WHERE (upper(old_name) = upper($1) OR upper(new_name) = upper($1))
		AND coord_dimension = $2;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_typmod_dims" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[postgis_typmod_dims]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_typmod_srid" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[postgis_typmod_srid]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_typmod_type" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[postgis_typmod_type]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_version" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns PostGIS version number and compile-time options.]]></comment>
         <definition language="C"><![CDATA[postgis_version]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_wagyu_version" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns the version number of the internal Wagyu library.]]></comment>
         <definition language="C"><![CDATA[postgis_wagyu_version]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="rename_column_if_exists" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
BEGIN
    -- Rename the column if it exists.
    IF column_exists(ptable, pcolumn) THEN
        EXECUTE FORMAT('ALTER TABLE %I RENAME COLUMN %I TO %I;',
                       ptable, pcolumn, new_name);
    END IF;
END
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_limit" returnType="real" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[set_limit]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="show_limit" returnType="real" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[show_limit]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="show_trgm" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[show_trgm]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="similarity" returnType="real" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[similarity]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="similarity_dist" returnType="real" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[similarity_dist]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="similarity_op" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[similarity_op]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="soundex" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[soundex]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="spheroid_in" returnType="spheroid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ellipsoid_in]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="spheroid_out" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ellipsoid_out]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dclosestpoint" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 3D point on g1 that is closest to g2. This is the first point of the 3D shortest line.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_closestpoint3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3ddfullywithin" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_dfullywithin3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3ddistance" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 3D cartesian minimum distance (based on spatial ref) between two geometries in projected units.]]></comment>
         <definition language="C"><![CDATA[ST_3DDistance]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3ddwithin" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_dwithin3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dextent" returnType="box3d" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: geomfield - an aggregate function that returns the 3D bounding box that bounds rows of geometries.]]></comment>
         <definition language="INTERNAL"><![CDATA[aggregate_dummy]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dintersects" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_3DIntersects]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dlength" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_3dlinestring - Returns the 3D length of a linear geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_length_linestring]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dlineinterpolatepoint" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_3DLineInterpolatePoint]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dlongestline" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 3D longest line between two geometries]]></comment>
         <definition language="C"><![CDATA[LWGEOM_longestline3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dmakebox" returnType="box3d" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: point3DLowLeftBottom, point3DUpRightTop - Creates a BOX3D defined by two 3D point geometries.]]></comment>
         <definition language="C"><![CDATA[BOX3D_construct]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dmaxdistance" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 3D cartesian maximum distance (based on spatial ref) between two geometries in projected units.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_maxdistance3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dperimeter" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns the 3D perimeter of a polygonal geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_perimeter_poly]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dshortestline" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 3D shortest line between two geometries]]></comment>
         <definition language="C"><![CDATA[LWGEOM_shortestline3d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_addmeasure" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom_mline, measure_start, measure_end - Return a derived geometry with measure elements linearly interpolated between the start and end points.]]></comment>
         <definition language="C"><![CDATA[ST_AddMeasure]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_addpoint" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: linestring, point, position - Add a point to a LineString.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_addpoint]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_affine" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, a, b, d, e, xoff, yoff - Apply a 3D affine transformation to a geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_affine]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_angle" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: line1, line2 - Returns the angle between 3 points, or between 2 vectors (4 points or 2 lines).]]></comment>
         <definition language="SQL"><![CDATA[SELECT ST_Angle(St_StartPoint($1), ST_EndPoint($1), St_StartPoint($2), ST_EndPoint($2))]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_area" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_area]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_area2d" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_Area]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asbinary" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_asBinary]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asencodedpolyline" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_asEncodedPolyline]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asewkb" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[WKBFromLWGEOM]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asewkt" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_asEWKT]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asgeobuf" returnType="bytea" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="INTERNAL"><![CDATA[aggregate_dummy]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asgeojson" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_as_geojson]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asgml" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_as_gml]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_ashexewkb" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_asHEXEWKB]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_askml" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_as_kml]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_aslatlontext" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_to_latlon]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asmvt" returnType="bytea" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="INTERNAL"><![CDATA[aggregate_dummy]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asmvtgeom" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_AsMVTGeom]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_assvg" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_as_svg]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_astext" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_asText]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_astwkb" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[TWKBFromLWGEOM]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asx3d" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[SELECT public._ST_AsX3D(3,$1,$2,$3,'');]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_azimuth" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: pointA, pointB - Returns the north-based azimuth as the angle in radians measured clockwise from the vertical on pointA to pointB.]]></comment>
         <definition language="C"><![CDATA[geography_azimuth]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_bdmpolyfromtext" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline public.geometry;
	geom public.geometry;
BEGIN
	mline := public.ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := public.ST_Multi(public.ST_BuildArea(mline));

	RETURN geom;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_bdpolyfromtext" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline public.geometry;
	geom public.geometry;
BEGIN
	mline := public.ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := public.ST_BuildArea(mline);

	IF public.GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_boundary" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns the boundary of a geometry.]]></comment>
         <definition language="C"><![CDATA[boundary]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_boundingdiagonal" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, fits=false - Returns the diagonal of a geometrys bounding box.]]></comment>
         <definition language="C"><![CDATA[ST_BoundingDiagonal]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_box2dfromgeohash" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[box2d_from_geohash]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_buffer" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[SELECT public.geography(public.ST_Transform(public.ST_Buffer(public.ST_Transform(public.geometry($1), public._ST_BestSRID($1)), $2), 4326))]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_buildarea" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: A - Creates an areal geometry formed by the constituent linework of given geometry]]></comment>
         <definition language="C"><![CDATA[ST_BuildArea]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_centroid" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_centroid]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_chaikinsmoothing" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, nIterations = 1, preserveEndPoints = false - Returns a "smoothed" version of the given geometry using the Chaikin algorithm]]></comment>
         <definition language="C"><![CDATA[LWGEOM_ChaikinSmoothing]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_cleangeometry" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_CleanGeometry]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_clipbybox2d" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, box - Returns the portion of a geometry falling within a rectangle.]]></comment>
         <definition language="C"><![CDATA[ST_ClipByBox2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_closestpoint" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 2D point on g1 that is closest to g2. This is the first point of the shortest line.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_closestpoint]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_closestpointofapproach" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: track1, track2 - Returns the measure at which points interpolated along two trajectories are closest.]]></comment>
         <definition language="C"><![CDATA[ST_ClosestPointOfApproach]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_clusterdbscan" returnType="integer" securityType="INVOKER" type="WINDOW">
         <comment><![CDATA[args: geom, eps, minpoints - Window function that returns a cluster id for each input geometry using the DBSCAN algorithm.]]></comment>
         <definition language="C"><![CDATA[ST_ClusterDBSCAN]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_clusterintersecting" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="INTERNAL"><![CDATA[aggregate_dummy]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="st_clusterkmeans" returnType="integer" securityType="INVOKER" type="WINDOW">
         <comment><![CDATA[args: geom, number_of_clusters - Window function that returns a cluster id for each input geometry using the K-means algorithm.]]></comment>
         <definition language="C"><![CDATA[ST_ClusterKMeans]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_clusterwithin" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="INTERNAL"><![CDATA[aggregate_dummy]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_collect" returnType="geometry" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: g1field - Creates a GeometryCollection or Multi* geometry from a set of geometries.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_collect]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_collectionextract" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: collection, type - Given a (multi)geometry, return a (multi)geometry consisting only of elements of the specified type.]]></comment>
         <definition language="C"><![CDATA[ST_CollectionExtract]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_collectionhomogenize" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: collection - Given a geometry collection, return the "simplest" representation of the contents.]]></comment>
         <definition language="C"><![CDATA[ST_CollectionHomogenize]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_combinebbox" returnType="box3d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[BOX3D_combine]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_concavehull" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, target_percent, allow_holes=false - The concave hull of a geometry represents a possibly concave geometry that encloses all geometries within the set. You can think of it as shrink wrapping.]]></comment>
         <definition language="PLPGSQL"><![CDATA[
	DECLARE
		var_convhull public.geometry := public.ST_ForceSFS(public.ST_ConvexHull(param_geom));
		var_param_geom public.geometry := public.ST_ForceSFS(param_geom);
		var_initarea float := public.ST_Area(var_convhull);
		var_newarea float := var_initarea;
		var_div integer := 6; 
		var_tempgeom public.geometry;
		var_tempgeom2 public.geometry;
		var_cent public.geometry;
		var_geoms public.geometry[4]; 
		var_enline public.geometry;
		var_resultgeom public.geometry;
		var_atempgeoms public.geometry[];
		var_buf float := 1; 
	BEGIN
		-- We start with convex hull as our base
		var_resultgeom := var_convhull;

		IF param_pctconvex = 1 THEN
			-- this is the same as asking for the convex hull
			return var_resultgeom;
		ELSIF public.ST_GeometryType(var_param_geom) = 'ST_Polygon' THEN -- it is as concave as it is going to get
			IF param_allow_holes THEN -- leave the holes
				RETURN var_param_geom;
			ELSE -- remove the holes
				var_resultgeom := public.ST_MakePolygon(public.ST_ExteriorRing(var_param_geom));
				RETURN var_resultgeom;
			END IF;
		END IF;
		IF public.ST_Dimension(var_resultgeom) > 1 AND param_pctconvex BETWEEN 0 and 0.99 THEN
		-- get linestring that forms envelope of geometry
			var_enline := public.ST_Boundary(public.ST_Envelope(var_param_geom));
			var_buf := public.ST_Length(var_enline)/1000.0;
			IF public.ST_GeometryType(var_param_geom) = 'ST_MultiPoint' AND public.ST_NumGeometries(var_param_geom) BETWEEN 4 and 200 THEN
			-- we make polygons out of points since they are easier to cave in.
			-- Note we limit to between 4 and 200 points because this process is slow and gets quadratically slow
				var_buf := sqrt(public.ST_Area(var_convhull)*0.8/(public.ST_NumGeometries(var_param_geom)*public.ST_NumGeometries(var_param_geom)));
				var_atempgeoms := ARRAY(SELECT geom FROM public.ST_DumpPoints(var_param_geom));
				-- 5 and 10 and just fudge factors
				var_tempgeom := public.ST_Union(ARRAY(SELECT geom
						FROM (
						-- fuse near neighbors together
						SELECT DISTINCT ON (i) i,  public.ST_Distance(var_atempgeoms[i],var_atempgeoms[j]), public.ST_Buffer(public.ST_MakeLine(var_atempgeoms[i], var_atempgeoms[j]) , var_buf*5, 'quad_segs=3') As geom
								FROM generate_series(1,array_upper(var_atempgeoms, 1)) As i
									INNER JOIN generate_series(1,array_upper(var_atempgeoms, 1)) As j
										ON (
								 NOT public.ST_Intersects(var_atempgeoms[i],var_atempgeoms[j])
									AND public.ST_DWithin(var_atempgeoms[i],var_atempgeoms[j], var_buf*10)
									)
								UNION ALL
						-- catch the ones with no near neighbors
								SELECT i, 0, public.ST_Buffer(var_atempgeoms[i] , var_buf*10, 'quad_segs=3') As geom
								FROM generate_series(1,array_upper(var_atempgeoms, 1)) As i
									LEFT JOIN generate_series(ceiling(array_upper(var_atempgeoms,1)/2)::integer,array_upper(var_atempgeoms, 1)) As j
										ON (
								 NOT public.ST_Intersects(var_atempgeoms[i],var_atempgeoms[j])
									AND public.ST_DWithin(var_atempgeoms[i],var_atempgeoms[j], var_buf*10)
									)
									WHERE j IS NULL
								ORDER BY 1, 2
							) As foo	) );
				IF public.ST_IsValid(var_tempgeom) AND public.ST_GeometryType(var_tempgeom) = 'ST_Polygon' THEN
					var_tempgeom := public.ST_ForceSFS(public.ST_Intersection(var_tempgeom, var_convhull));
					IF param_allow_holes THEN
						var_param_geom := var_tempgeom;
					ELSIF public.ST_GeometryType(var_tempgeom) = 'ST_Polygon' THEN
						var_param_geom := public.ST_ForceSFS(public.ST_MakePolygon(public.ST_ExteriorRing(var_tempgeom)));
					ELSE
						var_param_geom := public.ST_ForceSFS(public.ST_ConvexHull(var_param_geom));
					END IF;
					-- make sure result covers original (#3638)
					var_param_geom := public.ST_Union(param_geom, var_param_geom);
					return var_param_geom;
				ELSIF public.ST_IsValid(var_tempgeom) THEN
					var_param_geom := public.ST_ForceSFS(public.ST_Intersection(var_tempgeom, var_convhull));
				END IF;
			END IF;

			IF public.ST_GeometryType(var_param_geom) = 'ST_Polygon' THEN
				IF NOT param_allow_holes THEN
					var_param_geom := public.ST_ForceSFS(public.ST_MakePolygon(public.ST_ExteriorRing(var_param_geom)));
				END IF;
				-- make sure result covers original (#3638)
				--var_param_geom := public.ST_Union(param_geom, var_param_geom);
				return var_param_geom;
			END IF;
            var_cent := public.ST_Centroid(var_param_geom);
            IF (public.ST_XMax(var_enline) - public.ST_XMin(var_enline) ) > var_buf AND (public.ST_YMax(var_enline) - public.ST_YMin(var_enline) ) > var_buf THEN
                    IF public.ST_Dwithin(public.ST_Centroid(var_convhull) , public.ST_Centroid(public.ST_Envelope(var_param_geom)), var_buf/2) THEN
                -- If the geometric dimension is > 1 and the object is symettric (cutting at centroid will not work -- offset a bit)
                        var_cent := public.ST_Translate(var_cent, (public.ST_XMax(var_enline) - public.ST_XMin(var_enline))/1000,  (public.ST_YMAX(var_enline) - public.ST_YMin(var_enline))/1000);
                    ELSE
                        -- uses closest point on geometry to centroid. I can't explain why we are doing this
                        var_cent := public.ST_ClosestPoint(var_param_geom,var_cent);
                    END IF;
                    IF public.ST_DWithin(var_cent, var_enline,var_buf) THEN
                        var_cent := public.ST_centroid(public.ST_Envelope(var_param_geom));
                    END IF;
                    -- break envelope into 4 triangles about the centroid of the geometry and returned the clipped geometry in each quadrant
                    FOR i in 1 .. 4 LOOP
                       var_geoms[i] := public.ST_MakePolygon(public.ST_MakeLine(ARRAY[public.ST_PointN(var_enline,i), public.ST_PointN(var_enline,i+1), var_cent, public.ST_PointN(var_enline,i)]));
                       var_geoms[i] := public.ST_ForceSFS(public.ST_Intersection(var_param_geom, public.ST_Buffer(var_geoms[i],var_buf)));
                       IF public.ST_IsValid(var_geoms[i]) THEN

                       ELSE
                            var_geoms[i] := public.ST_BuildArea(public.ST_MakeLine(ARRAY[public.ST_PointN(var_enline,i), public.ST_PointN(var_enline,i+1), var_cent, public.ST_PointN(var_enline,i)]));
                       END IF;
                    END LOOP;
                    var_tempgeom := public.ST_Union(ARRAY[public.ST_ConvexHull(var_geoms[1]), public.ST_ConvexHull(var_geoms[2]) , public.ST_ConvexHull(var_geoms[3]), public.ST_ConvexHull(var_geoms[4])]);
                    --RAISE NOTICE 'Curr vex % ', public.ST_AsText(var_tempgeom);
                    IF public.ST_Area(var_tempgeom) <= var_newarea AND public.ST_IsValid(var_tempgeom)  THEN --AND public.ST_GeometryType(var_tempgeom) ILIKE '%Polygon'

                        var_tempgeom := public.ST_Buffer(public.ST_ConcaveHull(var_geoms[1],least(param_pctconvex + param_pctconvex/var_div),true),var_buf, 'quad_segs=2');
                        FOR i IN 1 .. 4 LOOP
                            var_geoms[i] := public.ST_Buffer(public.ST_ConcaveHull(var_geoms[i],least(param_pctconvex + param_pctconvex/var_div),true), var_buf, 'quad_segs=2');
                            IF public.ST_IsValid(var_geoms[i]) Then
                                var_tempgeom := public.ST_Union(var_tempgeom, var_geoms[i]);
                            ELSE
                                RAISE NOTICE 'Not valid % %', i, public.ST_AsText(var_tempgeom);
                                var_tempgeom := public.ST_Union(var_tempgeom, public.ST_ConvexHull(var_geoms[i]));
                            END IF;
                        END LOOP;

                        --RAISE NOTICE 'Curr concave % ', public.ST_AsText(var_tempgeom);
                        IF public.ST_IsValid(var_tempgeom) THEN
                            var_resultgeom := var_tempgeom;
                        END IF;
                        var_newarea := public.ST_Area(var_resultgeom);
                    ELSIF public.ST_IsValid(var_tempgeom) THEN
                        var_resultgeom := var_tempgeom;
                    END IF;

                    IF public.ST_NumGeometries(var_resultgeom) > 1  THEN
                        var_tempgeom := public._ST_ConcaveHull(var_resultgeom);
                        IF public.ST_IsValid(var_tempgeom) AND public.ST_GeometryType(var_tempgeom) ILIKE 'ST_Polygon' THEN
                            var_resultgeom := var_tempgeom;
                        ELSE
                            var_resultgeom := public.ST_Buffer(var_tempgeom,var_buf, 'quad_segs=2');
                        END IF;
                    END IF;
                    IF param_allow_holes = false THEN
                    -- only keep exterior ring since we do not want holes
                        var_resultgeom := public.ST_MakePolygon(public.ST_ExteriorRing(var_resultgeom));
                    END IF;
                ELSE
                    var_resultgeom := public.ST_Buffer(var_resultgeom,var_buf);
                END IF;
                var_resultgeom := public.ST_ForceSFS(public.ST_Intersection(var_resultgeom, public.ST_ConvexHull(var_param_geom)));
            ELSE
                -- dimensions are too small to cut
                var_resultgeom := public._ST_ConcaveHull(var_param_geom);
            END IF;

            RETURN var_resultgeom;
	END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_contains" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[contains]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_containsproperly" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[containsproperly]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_convexhull" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Computes the convex hull of a geometry.]]></comment>
         <definition language="C"><![CDATA[convexhull]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_coorddim" returnType="smallint" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Return the coordinate dimension of a geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_ndims]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_coveredby" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_coveredby]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_covers" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_covers]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_cpawithin" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: track1, track2, maxdist - Returns true if the closest point of approach of two trajectoriesis within the specified distance.]]></comment>
         <definition language="C"><![CDATA[ST_CPAWithin]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_crosses" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[crosses]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_curvetoline" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: curveGeom, tolerance, tolerance_type, flags - Converts a CIRCULARSTRING/CURVEPOLYGON/MULTISURFACE to a LINESTRING/POLYGON/MULTIPOLYGON]]></comment>
         <definition language="C"><![CDATA[ST_CurveToLine]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_delaunaytriangles" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, tolerance, flags - Return a Delaunay triangulation around the given input points.]]></comment>
         <definition language="C"><![CDATA[ST_DelaunayTriangles]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_dfullywithin" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_dfullywithin]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_difference" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, geomB - Returns a geometry that represents that part of geometry A that does not intersect with geometry B.]]></comment>
         <definition language="C"><![CDATA[ST_Difference]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_dimension" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Returns the topological dimension of a geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_dimension]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_disjoint" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[disjoint]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_distance" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_distance]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_distancecpa" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: track1, track2 - Returns the distance between the closest point of approach of two trajectories.]]></comment>
         <definition language="C"><![CDATA[ST_DistanceCPA]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_distancesphere" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomlonlatA, geomlonlatB - Returns minimum distance in meters between two lon/lat geometries using a spherical earth model.]]></comment>
         <definition language="SQL"><![CDATA[select public.ST_distance( public.geography($1), public.geography($2),false)]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_distancespheroid" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomlonlatA, geomlonlatB, measurement_spheroid - Returns the minimum distance between two lon/lat geometries using a spheroidal earth model.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_distance_ellipsoid]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_dump" returnType="SETOF geometry_dump" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns a set of geometry_dump rows for the components of a geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_dump]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_dumppoints" returnType="SETOF geometry_dump" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Returns a set of geometry_dump rows for the points in a geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_dumppoints]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_dumprings" returnType="SETOF geometry_dump" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_polygon - Returns a set of geometry_dump rows for the exterior and interior rings of a Polygon.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_dump_rings]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_dwithin" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_dwithin]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_endpoint" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Returns the last point of a LineString or CircularLineString.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_endpoint_linestring]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_envelope" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns a geometry representing the bounding box of a geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_envelope]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_equals" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_Equals]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="st_estimatedextent" returnType="box2d" securityType="DEFINER" type="FUNCTION">
         <comment><![CDATA[args: table_name, geocolumn_name - Return the estimated extent of a spatial table.]]></comment>
         <definition language="C"><![CDATA[gserialized_estimated_extent]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_expand" returnType="box3d" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: box, dx, dy, dz=0 - Returns a bounding box expanded from another bounding box or a geometry.]]></comment>
         <definition language="C"><![CDATA[BOX3D_expand]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_extent" returnType="box2d" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: geomfield - an aggregate function that returns the bounding box that bounds rows of geometries.]]></comment>
         <definition language="INTERNAL"><![CDATA[aggregate_dummy]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_exteriorring" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_polygon - Returns a LineString representing the exterior ring of a Polygon.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_exteriorring_polygon]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_filterbym" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, min, max = null, returnM = false - Filters vertex points based on their m-value]]></comment>
         <definition language="C"><![CDATA[LWGEOM_FilterByM]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="st_findextent" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;
BEGIN
	FOR myrec IN EXECUTE 'SELECT public.ST_Extent("' || columnname || '") As extent FROM "' || schemaname || '"."' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_flipcoordinates" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Returns a version of the given geometry with X and Y axis flipped. Useful for people who have built latitude/longitude features and need to fix them.]]></comment>
         <definition language="C"><![CDATA[ST_FlipCoordinates]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_force2d" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Force the geometries into a "2-dimensional mode".]]></comment>
         <definition language="C"><![CDATA[LWGEOM_force_2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_force3d" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Force the geometries into XYZ mode. This is an alias for ST_Force3DZ.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_force_3dz]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_force3dm" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Force the geometries into XYM mode.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_force_3dm]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_force3dz" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Force the geometries into XYZ mode.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_force_3dz]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_force4d" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Force the geometries into XYZM mode.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_force_4d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_forcecollection" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Convert the geometry into a GEOMETRYCOLLECTION.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_force_collection]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_forcecurve" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Upcast a geometry into its curved type, if applicable.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_force_curve]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_forcepolygonccw" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Orients all exterior rings counter-clockwise and all interior rings clockwise.]]></comment>
         <definition language="SQL"><![CDATA[ SELECT public.ST_Reverse(public.ST_ForcePolygonCW($1)) ]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_forcepolygoncw" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Orients all exterior rings clockwise and all interior rings counter-clockwise.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_force_clockwise_poly]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_forcerhr" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Force the orientation of the vertices in a polygon to follow the Right-Hand-Rule.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_force_clockwise_poly]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_forcesfs" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, version - Force the geometries to use SFS 1.1 geometry types only.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_force_sfs]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_frechetdistance" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2, densifyFrac = -1 - Returns the Fréchet distance between two geometries.]]></comment>
         <definition language="C"><![CDATA[ST_FrechetDistance]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="st_generatepoints" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g, npoints, seed - Converts a polygon or multi-polygon into a multi-point composed of randomly location points within the original areas.]]></comment>
         <definition language="C"><![CDATA[ST_GeneratePoints]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geogfromtext" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_from_text]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geogfromwkb" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_from_binary]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geographyfromtext" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_from_text]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geohash" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_GeoHash]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomcollfromtext" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE
	WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN public.ST_GeomFromText($1,$2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomcollfromwkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE
	WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geometricmedian" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: 
					g
				, 
					tolerance
				, 
					max_iter
				, 
					fail_if_not_converged
				 - Returns the geometric median of a MultiPoint.]]></comment>
         <definition language="C"><![CDATA[ST_GeometricMedian]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geometryfromtext" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_from_text]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geometryn" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, n - Return the Nth geometry element of a geometry collection.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_geometryn_collection]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geometrytype" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns the SQL-MM type of a geometry as text.]]></comment>
         <definition language="C"><![CDATA[geometry_geometrytype]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromewkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOMFromEWKB]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromewkt" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[parse_WKT_lwgeom]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromgeohash" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[ SELECT CAST(public.ST_Box2dFromGeoHash($1, $2) AS geometry); ]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromgeojson" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geom_from_geojson]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromgml" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geom_from_gml]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromkml" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geom_from_kml]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromtext" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_from_text]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromtwkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOMFromTWKB]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromwkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_from_WKB]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_gmltosql" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[SELECT public._ST_GeomFromGML($1, 0)]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_hasarc" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Tests if a geometry contains a circular arc]]></comment>
         <definition language="C"><![CDATA[LWGEOM_has_arc]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_hausdorffdistance" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2, densifyFrac - Returns the Hausdorff distance between two geometries.]]></comment>
         <definition language="C"><![CDATA[hausdorffdistance]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_interiorringn" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_polygon, n - Returns the Nth interior ring (hole) of a Polygon.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_interiorringn_polygon]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_interpolatepoint" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: line, point - Return the value of the measure dimension of a geometry at the point closed to the provided point.]]></comment>
         <definition language="C"><![CDATA[ST_InterpolatePoint]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_intersection" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[SELECT public.geography(public.ST_Transform(public.ST_Intersection(public.ST_Transform(public.geometry($1), public._ST_BestSRID($1, $2)), public.ST_Transform(public.geometry($2), public._ST_BestSRID($1, $2))), 4326))]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_intersects" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[geography_intersects]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isclosed" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Tests if a LineStringss start and end points are coincident. For a PolyhedralSurface tests if it is closed (volumetric).]]></comment>
         <definition language="C"><![CDATA[LWGEOM_isclosed]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_iscollection" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Tests if a geometry is a geometry collection type.]]></comment>
         <definition language="C"><![CDATA[ST_IsCollection]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isempty" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Tests if a geometry is empty.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_isempty]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_ispolygonccw" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Tests if Polygons have exterior rings oriented counter-clockwise and interior rings oriented clockwise.]]></comment>
         <definition language="C"><![CDATA[ST_IsPolygonCCW]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_ispolygoncw" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Tests if Polygons have exterior rings oriented clockwise and interior rings oriented counter-clockwise.]]></comment>
         <definition language="C"><![CDATA[ST_IsPolygonCW]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isring" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Tests if a LineString is closed and simple.]]></comment>
         <definition language="C"><![CDATA[isring]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_issimple" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Tests if a geometry has no points of self-intersection or self-tangency.]]></comment>
         <definition language="C"><![CDATA[issimple]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isvalid" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g, flags - Tests if a geometry is well-formed in 2D.]]></comment>
         <definition language="C"><![CDATA[isvalid]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isvaliddetail" returnType="valid_detail" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, flags - Returns a valid_detail row stating if a geometry is valid, and if not a reason why and a location.]]></comment>
         <definition language="C"><![CDATA[isvaliddetail]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isvalidreason" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns text stating if a geometry is valid, or a reason for invalidity.]]></comment>
         <definition language="C"><![CDATA[isvalidreason]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isvalidtrajectory" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: line - Returns true if the geometry is a valid trajectory.]]></comment>
         <definition language="C"><![CDATA[ST_IsValidTrajectory]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_length" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[ SELECT public.ST_Length($1::public.geometry);  ]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_length2d" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_2dlinestring - Returns the 2D length of a linear geometry. Alias for ST_Length]]></comment>
         <definition language="C"><![CDATA[LWGEOM_length2d_linestring]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_length2dspheroid" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_length2d_ellipsoid]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_lengthspheroid" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_geometry, a_spheroid - Returns the 2D or 3D length/perimeter of a lon/lat geometry on a spheroid.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_length_ellipsoid_linestring]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linecrossingdirection" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_LineCrossingDirection]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linefromencodedpolyline" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[line_from_encoded_polyline]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linefrommultipoint" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: aMultiPoint - Creates a LineString from a MultiPoint geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_line_from_mpoint]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linefromtext" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'LINESTRING'
	THEN public.ST_GeomFromText($1)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linefromwkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_lineinterpolatepoint" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_linestring, a_fraction - Returns a point interpolated along a line in 3D. Second argument is a float8 between 0 and 1 representing fraction of total length of linestring the point has to be located.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_line_interpolate_point]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_lineinterpolatepoints" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_linestring, a_fraction, repeat - Returns one or more points interpolated along a line.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_line_interpolate_point]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linelocatepoint" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_linestring, a_point - Returns a float between 0 and 1 representing the location of the closest point on LineString to the given Point, as a fraction of total 2d line length.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_line_locate_point]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linemerge" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: amultilinestring - Return a (set of) LineString(s) formed by sewing together a MULTILINESTRING.]]></comment>
         <definition language="C"><![CDATA[linemerge]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linestringfromwkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linesubstring" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_linestring, startfraction, endfraction - Return a linestring being a substring of the input one starting and ending at the given fractions of total 2d length. Second and third arguments are float8 values between 0 and 1.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_line_substring]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linetocurve" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomANoncircular - Converts a LINESTRING/POLYGON to a CIRCULARSTRING, CURVEPOLYGON]]></comment>
         <definition language="C"><![CDATA[LWGEOM_line_desegmentize]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_locatealong" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: ageom_with_measure, a_measure, offset - Return a derived geometry collection value with elements that match the specified measure. Polygonal elements are not supported.]]></comment>
         <definition language="C"><![CDATA[ST_LocateAlong]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_locatebetween" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, measure_start, measure_end, offset - Return a derived geometry collection value with elements that match the specified range of measures inclusively.]]></comment>
         <definition language="C"><![CDATA[ST_LocateBetween]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_locatebetweenelevations" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, elevation_start, elevation_end - Return a derived geometry (collection) value with elements that intersect the specified range of elevations inclusively.]]></comment>
         <definition language="C"><![CDATA[ST_LocateBetweenElevations]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_longestline" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 2D longest line between two geometries.]]></comment>
         <definition language="SQL"><![CDATA[SELECT public._ST_LongestLine(public.ST_ConvexHull($1), public.ST_ConvexHull($2))]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_m" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_point - Returns the M coordinate of a Point.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_m_point]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makebox2d" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: pointLowLeft, pointUpRight - Creates a BOX2D defined by two 2D point geometries.]]></comment>
         <definition language="C"><![CDATA[BOX2D_construct]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makeenvelope" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: xmin, ymin, xmax, ymax, srid=unknown - Creates a rectangular Polygon from minimum and maximum coordinates.]]></comment>
         <definition language="C"><![CDATA[ST_MakeEnvelope]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makeline" returnType="geometry" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: geoms - Creates a Linestring from Point, MultiPoint, or LineString geometries.]]></comment>
         <definition language="INTERNAL"><![CDATA[aggregate_dummy]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makepoint" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: x, y, z, m - Creates a 2D, 3DZ or 4D Point.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_makepoint]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makepointm" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: x, y, m - Creates a Point from X, Y and M values.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_makepoint3dm]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makepolygon" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: outerlinestring, interiorlinestrings - Creates a Polygon from a shell and optional list of holes.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_makepoly]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makevalid" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: input - Attempts to make an invalid geometry valid without losing vertices.]]></comment>
         <definition language="C"><![CDATA[ST_MakeValid]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_maxdistance" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 2D largest distance between two geometries in projected units.]]></comment>
         <definition language="SQL"><![CDATA[SELECT public._ST_MaxDistance(public.ST_ConvexHull($1), public.ST_ConvexHull($2))]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_memcollect" returnType="geometry" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="INTERNAL"><![CDATA[aggregate_dummy]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_memsize" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns the amount of memory space a geometry takes.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_mem_size]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_memunion" returnType="geometry" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: geomfield - Same as ST_Union, only memory-friendly (uses less memory and more processor time).]]></comment>
         <definition language="INTERNAL"><![CDATA[aggregate_dummy]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_minimumboundingcircle" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, num_segs_per_qt_circ=48 - Returns the smallest circle polygon that can fully contain a geometry. Default uses 48 segments per quarter circle.]]></comment>
         <definition language="C"><![CDATA[ST_MinimumBoundingCircle]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_minimumboundingradius" returnType="record" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Returns the center point and radius of the smallest circle that can fully contain a geometry.]]></comment>
         <definition language="C"><![CDATA[ST_MinimumBoundingRadius]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_minimumclearance" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Returns the minimum clearance of a geometry, a measure of a geometrys robustness.]]></comment>
         <definition language="C"><![CDATA[ST_MinimumClearance]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_minimumclearanceline" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Returns the two-point LineString spanning a geometrys minimum clearance.]]></comment>
         <definition language="C"><![CDATA[ST_MinimumClearanceLine]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mlinefromtext" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE
	WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'MULTILINESTRING'
	THEN public.ST_GeomFromText($1,$2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mlinefromwkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'MULTILINESTRING'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mpointfromtext" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'MULTIPOINT'
	THEN ST_GeomFromText($1, $2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mpointfromwkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'MULTIPOINT'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mpolyfromtext" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'MULTIPOLYGON'
	THEN public.ST_GeomFromText($1,$2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mpolyfromwkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multi" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Return the geometry as a MULTI* geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_force_multi]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multilinefromwkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN public.ST_GeomFromWKB($1)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multilinestringfromtext" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[SELECT public.ST_MLineFromText($1)]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multipointfromtext" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[SELECT public.ST_MPointFromText($1)]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multipointfromwkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1,$2)) = 'MULTIPOINT'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multipolyfromwkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multipolygonfromtext" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[SELECT public.ST_MPolyFromText($1)]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_ndims" returnType="smallint" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns the coordinate dimension of a geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_ndims]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_node" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Node a set of linestrings.]]></comment>
         <definition language="C"><![CDATA[ST_Node]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_normalize" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Return the geometry in its canonical form.]]></comment>
         <definition language="C"><![CDATA[ST_Normalize]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_npoints" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns the number of points (vertices) in a geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_npoints]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_nrings" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns the number of rings in a polygonal geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_nrings]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_numgeometries" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Returns the number of elements in a geometry collection.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_numgeometries_collection]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_numinteriorring" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_polygon - Returns the number of interior rings (holes) of a Polygon. Aias for ST_NumInteriorRings]]></comment>
         <definition language="C"><![CDATA[LWGEOM_numinteriorrings_polygon]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_numinteriorrings" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_polygon - Returns the number of interior rings (holes) of a Polygon.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_numinteriorrings_polygon]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_numpatches" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Return the number of faces on a Polyhedral Surface. Will return null for non-polyhedral geometries.]]></comment>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.ST_GeometryType($1) = 'ST_PolyhedralSurface'
	THEN public.ST_NumGeometries($1)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_numpoints" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns the number of points in a LineString or CircularString.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_numpoints_linestring]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_offsetcurve" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: line, signed_distance, style_parameters=' - Return an offset line at a given distance and side from an input line. Useful for computing parallel lines about a center line]]></comment>
         <definition language="C"><![CDATA[ST_OffsetCurve]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_orderingequals" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_same]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_orientedenvelope" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Returns a minimum rotated rectangle enclosing a geometry.]]></comment>
         <definition language="C"><![CDATA[ST_OrientedEnvelope]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_overlaps" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[overlaps]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_patchn" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, n - Returns the Nth geometry (face) of a PolyhedralSurface.]]></comment>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.ST_GeometryType($1) = 'ST_PolyhedralSurface'
	THEN public.ST_GeometryN($1, $2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_perimeter" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geog, use_spheroid=true - Returns the length of the boundary of a polygonal geometry or geography.]]></comment>
         <definition language="C"><![CDATA[geography_perimeter]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_perimeter2d" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns the 2D perimeter of a polygonal geometry. Alias for ST_Perimeter.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_perimeter2d_poly]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_point" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: x, y - Creates a Point with the given coordinate values. Alias for ST_MakePoint.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_makepoint]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointfromgeohash" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[point_from_geohash]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointfromtext" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'POINT'
	THEN public.ST_GeomFromText($1)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointfromwkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'POINT'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointinsidecircle" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_inside_circle_point]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointn" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_linestring, n - Returns the Nth point in the first LineString or circular LineString in a geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_pointn_linestring]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointonsurface" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns a POINT guaranteed to lie on the surface.]]></comment>
         <definition language="C"><![CDATA[pointonsurface]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_points" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Returns a MultiPoint containing all the coordinates of a geometry.]]></comment>
         <definition language="C"><![CDATA[ST_Points]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polyfromtext" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'POLYGON'
	THEN public.ST_GeomFromText($1)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polyfromwkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'POLYGON'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polygon" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: lineString, srid - Creates a Polygon from a LineString with a specified SRID.]]></comment>
         <definition language="SQL"><![CDATA[
	SELECT public.ST_SetSRID(public.ST_MakePolygon($1), $2)
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polygonfromtext" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[SELECT public.ST_PolyFromText($1, $2)]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polygonfromwkb" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
	SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1,$2)) = 'POLYGON'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END
	]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polygonize" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom_array - Aggregate. Creates a GeometryCollection containing possible polygons formed from the constituent linework of a set of geometries.]]></comment>
         <definition language="INTERNAL"><![CDATA[aggregate_dummy]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_project" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, distance, azimuth - Returns a point projected from a start point by a distance and bearing (azimuth).]]></comment>
         <definition language="C"><![CDATA[geography_project]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_quantizecoordinates" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g, prec_x, prec_y, prec_z, prec_m - Sets least significant bits of coordinates to zero]]></comment>
         <definition language="C"><![CDATA[ST_QuantizeCoordinates]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_relate" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[relate_full]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_relatematch" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[ST_RelateMatch]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_removepoint" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: linestring, offset - Remove point from a linestring.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_removepoint]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_removerepeatedpoints" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, tolerance - Returns a version of the given geometry with duplicated points removed.]]></comment>
         <definition language="C"><![CDATA[ST_RemoveRepeatedPoints]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_reverse" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Return the geometry with vertex order reversed.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_reverse]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_rotate" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, rotRadians, pointOrigin - Rotates a geometry about an origin point.]]></comment>
         <definition language="SQL"><![CDATA[SELECT public.ST_Affine($1,  cos($2), -sin($2), 0,  sin($2), cos($2), 0,  0, 0, 1,  0, 0, 0)]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_rotatex" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, rotRadians - Rotates a geometry about the X axis.]]></comment>
         <definition language="SQL"><![CDATA[SELECT public.ST_Affine($1, 1, 0, 0, 0, cos($2), -sin($2), 0, sin($2), cos($2), 0, 0, 0)]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_rotatey" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, rotRadians - Rotates a geometry about the Y axis.]]></comment>
         <definition language="SQL"><![CDATA[SELECT public.ST_Affine($1,  cos($2), 0, sin($2),  0, 1, 0,  -sin($2), 0, cos($2), 0,  0, 0)]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_rotatez" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, rotRadians - Rotates a geometry about the Z axis.]]></comment>
         <definition language="SQL"><![CDATA[SELECT public.ST_Rotate($1, $2)]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_scale" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, factor, origin - Scales a geometry by given factors.]]></comment>
         <definition language="C"><![CDATA[ST_Scale]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_segmentize" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geog, max_segment_length - Return a modified geometry/geography having no segment longer than the given distance.]]></comment>
         <definition language="C"><![CDATA[geography_segmentize]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_seteffectivearea" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, threshold = 0, set_area = 1 - Sets the effective area for each vertex, storing the value in the M ordinate. A simplified geometry can then be generated by filtering on the M ordinate.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_SetEffectiveArea]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_setpoint" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: linestring, zerobasedposition, point - Replace point of a linestring with a given point.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_setpoint_linestring]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_setsrid" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_set_srid]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_sharedpaths" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: lineal1, lineal2 - Returns a collection containing paths shared by the two input linestrings/multilinestrings.]]></comment>
         <definition language="C"><![CDATA[ST_SharedPaths]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_shiftlongitude" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Toggle geometry coordinates between -180..180 and 0..360 ranges.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_longitude_shift]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_shortestline" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 2D shortest line between two geometries]]></comment>
         <definition language="C"><![CDATA[LWGEOM_shortestline2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_simplify" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_simplify2d]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_simplifypreservetopology" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, tolerance - Returns a "simplified" version of the given geometry using the Douglas-Peucker algorithm. Will avoid creating derived geometries (polygons in particular) that are invalid.]]></comment>
         <definition language="C"><![CDATA[topologypreservesimplify]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_simplifyvw" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, tolerance - Returns a "simplified" version of the given geometry using the Visvalingam-Whyatt algorithm]]></comment>
         <definition language="C"><![CDATA[LWGEOM_SetEffectiveArea]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_snap" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: input, reference, tolerance - Snap segments and vertices of input geometry to vertices of a reference geometry.]]></comment>
         <definition language="C"><![CDATA[ST_Snap]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_snaptogrid" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, pointOrigin, sizeX, sizeY, sizeZ, sizeM - Snap all points of the input geometry to a regular grid.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_snaptogrid]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_split" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: input, blade - Returns a collection of geometries resulting by splitting a geometry.]]></comment>
         <definition language="C"><![CDATA[ST_Split]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_srid" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_get_srid]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_startpoint" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns the first point of a LineString.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_startpoint_linestring]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_subdivide" returnType="SETOF geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, max_vertices=256 - Returns a set of geometry where no geometry in the set has more than the specified number of vertices.]]></comment>
         <definition language="C"><![CDATA[ST_Subdivide]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_summary" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Returns a text summary of the contents of a geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_summary]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_swapordinates" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, ords - Returns a version of the given geometry with given ordinate values swapped.]]></comment>
         <definition language="C"><![CDATA[ST_SwapOrdinates]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_symdifference" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, geomB - Returns a geometry that represents the portions of A and B that do not intersect. It is called a symmetric difference because ST_SymDifference(A,B) = ST_SymDifference(B,A).]]></comment>
         <definition language="C"><![CDATA[symdifference]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_symmetricdifference" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[symdifference]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_tileenvelope" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: tileZoom, tileX, tileY, bounds=SRID=3857;LINESTRING(-20037508.342789 -20037508.342789,20037508.342789 20037508.342789) - Creates a rectangular Polygon in Web Mercator (SRID:3857) using the XYZ tile system.]]></comment>
         <definition language="C"><![CDATA[ST_TileEnvelope]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_touches" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[touches]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_transform" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, from_proj, to_srid - Return a new geometry with its coordinates transformed to a different spatial reference system.]]></comment>
         <definition language="C"><![CDATA[transform]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_translate" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, deltax, deltay, deltaz - Translates a geometry by given offsets.]]></comment>
         <definition language="SQL"><![CDATA[SELECT public.ST_Affine($1, 1, 0, 0, 0, 1, 0, 0, 0, 1, $2, $3, $4)]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_transscale" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, deltaX, deltaY, XFactor, YFactor - Translates and scales a geometry by given offsets and factors.]]></comment>
         <definition language="SQL"><![CDATA[SELECT public.ST_Affine($1,  $4, 0, 0,  0, $5, 0,
		0, 0, 1,  $2 * $4, $3 * $5, 0)]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_unaryunion" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Like ST_Union, but working at the geometry component level.]]></comment>
         <definition language="C"><![CDATA[ST_UnaryUnion]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_union" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1_array - Returns a geometry that represents the point set union of the Geometries.]]></comment>
         <definition language="C"><![CDATA[ST_Union]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_voronoilines" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, tolerance, extend_to - Returns the boundaries between the cells of the Voronoi diagram constructed from the vertices of a geometry.]]></comment>
         <definition language="SQL"><![CDATA[ SELECT public._ST_Voronoi(g1, extend_to, tolerance, false) ]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_voronoipolygons" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, tolerance, extend_to - Returns the cells of the Voronoi diagram constructed from the vertices of a geometry.]]></comment>
         <definition language="SQL"><![CDATA[ SELECT public._ST_Voronoi(g1, extend_to, tolerance, true) ]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_within" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[within]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_wkbtosql" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_from_WKB]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_wkttosql" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_from_text]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_wrapx" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, wrap, move - Wrap a geometry around an X value.]]></comment>
         <definition language="C"><![CDATA[ST_WrapX]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_x" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_point - Returns the X coordinate of a Point.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_x_point]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_xmax" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: aGeomorBox2DorBox3D - Returns the X maxima of a 2D or 3D bounding box or a geometry.]]></comment>
         <definition language="C"><![CDATA[BOX3D_xmax]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_xmin" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: aGeomorBox2DorBox3D - Returns the X minima of a 2D or 3D bounding box or a geometry.]]></comment>
         <definition language="C"><![CDATA[BOX3D_xmin]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_y" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_point - Returns the Y coordinate of a Point.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_y_point]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_ymax" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: aGeomorBox2DorBox3D - Returns the Y maxima of a 2D or 3D bounding box or a geometry.]]></comment>
         <definition language="C"><![CDATA[BOX3D_ymax]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_ymin" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: aGeomorBox2DorBox3D - Returns the Y minima of a 2D or 3D bounding box or a geometry.]]></comment>
         <definition language="C"><![CDATA[BOX3D_ymin]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_z" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_point - Returns the Z coordinate of a Point.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_z_point]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_zmax" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: aGeomorBox2DorBox3D - Returns the Z maxima of a 2D or 3D bounding box or a geometry.]]></comment>
         <definition language="C"><![CDATA[BOX3D_zmax]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_zmflag" returnType="smallint" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns a code indicating the ZM coordinate dimension of a geometry.]]></comment>
         <definition language="C"><![CDATA[LWGEOM_zmflag]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_zmin" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: aGeomorBox2DorBox3D - Returns the Z minima of a 2D or 3D bounding box or a geometry.]]></comment>
         <definition language="C"><![CDATA[BOX3D_zmin]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="strict_word_similarity" returnType="real" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[strict_word_similarity]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="strict_word_similarity_commutator_op" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[strict_word_similarity_commutator_op]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="strict_word_similarity_dist_commutator_op" returnType="real" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[strict_word_similarity_dist_commutator_op]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="strict_word_similarity_dist_op" returnType="real" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[strict_word_similarity_dist_op]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="strict_word_similarity_op" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[strict_word_similarity_op]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="text" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[LWGEOM_to_text]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="text_soundex" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[soundex]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="unlockrows" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: auth_token - Removes all locks held by an authorization token.]]></comment>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	ret int;
BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	EXECUTE 'DELETE FROM authorization_table where authid = ' ||
		quote_literal($1);

	GET DIAGNOSTICS ret = ROW_COUNT;

	RETURN ret;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="updategeometrysrid" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: catalog_name, schema_name, table_name, column_name, srid - Updates the SRID of all features in a geometry column, and the table metadata.]]></comment>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	myrec RECORD;
	okay boolean;
	cname varchar;
	real_schema name;
	unknown_srid integer;
	new_srid integer := new_srid_in;

BEGIN

	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = false;

		FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := true;
		END LOOP;

		IF ( okay <> true ) THEN
			RAISE EXCEPTION 'Invalid schema name';
		ELSE
			real_schema = schema_name;
		END IF;
	ELSE
		SELECT INTO real_schema current_schema()::text;
	END IF;

	-- Ensure that column_name is in geometry_columns
	okay = false;
	FOR myrec IN SELECT type, coord_dimension FROM public.geometry_columns WHERE f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := true;
	END LOOP;
	IF (NOT okay) THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
		RETURN false;
	END IF;

	-- Ensure that new_srid is valid
	IF ( new_srid > 0 ) THEN
		IF ( SELECT count(*) = 0 from spatial_ref_sys where srid = new_srid ) THEN
			RAISE EXCEPTION 'invalid SRID: % not found in spatial_ref_sys', new_srid;
			RETURN false;
		END IF;
	ELSE
		unknown_srid := public.ST_SRID('POINT EMPTY'::public.geometry);
		IF ( new_srid != unknown_srid ) THEN
			new_srid := unknown_srid;
			RAISE NOTICE 'SRID value % converted to the officially unknown SRID value %', new_srid_in, new_srid;
		END IF;
	END IF;

	IF postgis_constraint_srid(real_schema, table_name, column_name) IS NOT NULL THEN
	-- srid was enforced with constraints before, keep it that way.
        -- Make up constraint name
        cname = 'enforce_srid_'  || column_name;

        -- Drop enforce_srid constraint
        EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
            '.' || quote_ident(table_name) ||
            ' DROP constraint ' || quote_ident(cname);

        -- Update geometries SRID
        EXECUTE 'UPDATE ' || quote_ident(real_schema) ||
            '.' || quote_ident(table_name) ||
            ' SET ' || quote_ident(column_name) ||
            ' = public.ST_SetSRID(' || quote_ident(column_name) ||
            ', ' || new_srid::text || ')';

        -- Reset enforce_srid constraint
        EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
            '.' || quote_ident(table_name) ||
            ' ADD constraint ' || quote_ident(cname) ||
            ' CHECK (st_srid(' || quote_ident(column_name) ||
            ') = ' || new_srid::text || ')';
    ELSE
        -- We will use typmod to enforce if no srid constraints
        -- We are using postgis_type_name to lookup the new name
        -- (in case Paul changes his mind and flips geometry_columns to return old upper case name)
        EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' || quote_ident(table_name) ||
        ' ALTER COLUMN ' || quote_ident(column_name) || ' TYPE  geometry(' || public.postgis_type_name(myrec.type, myrec.coord_dimension, true) || ', ' || new_srid::text || ') USING public.ST_SetSRID(' || quote_ident(column_name) || ',' || new_srid::text || ');' ;
    END IF;

	RETURN real_schema || '.' || table_name || '.' || column_name ||' SRID changed to ' || new_srid::text;

END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="word_similarity" returnType="real" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[word_similarity]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="word_similarity_commutator_op" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[word_similarity_commutator_op]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="word_similarity_dist_commutator_op" returnType="real" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[word_similarity_dist_commutator_op]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="word_similarity_dist_op" returnType="real" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[word_similarity_dist_op]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="word_similarity_op" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"><![CDATA[word_similarity_op]]></definition>
      </routine>
   </routines>
</database>
