-- Schema updates to reflect changes in seed bank app product spec. The idea is to make the
-- data model as simple as possible to support the updated requirements, unless doing so would
-- make it significantly harder to restore functionality that's been trimmed from the initial
-- version of the app.

-- There is a new "family" field to hold the family name of the seed species for each accession.
-- For version 1, there is no software-enforced association between species and family; they are
-- treated as independent values.
CREATE TABLE species_family (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name TEXT NOT NULL,
    created_time TIMESTAMP WITH TIME ZONE NOT NULL,
    UNIQUE (name)
);

ALTER TABLE accession ADD COLUMN species_family_id BIGINT REFERENCES species_family;

-- We are not doing species normalization in version 1, just treating species as a free-text
-- value with fuzzy matching and no concept of localization, so move the species name from the
-- localized species_name table to the species table.
ALTER TABLE species DROP COLUMN needs_review;
ALTER TABLE species ADD COLUMN name TEXT;

UPDATE species s
SET name = (
    SELECT name
    FROM species_name n
    WHERE n.species_id = s.id
    ORDER BY n.modified_time
    LIMIT 1
);

ALTER TABLE species ALTER COLUMN name SET NOT NULL;

DROP TABLE species_name;

-- "Rare" and "endangered" become accession attributes rather than species attributes. They may have
-- different values for different accessions of the same species.
ALTER TABLE accession ADD COLUMN species_rare BOOLEAN;
ALTER TABLE accession ADD COLUMN species_endangered BOOLEAN;

UPDATE accession a
SET species_rare       = s.rare,
    species_endangered = s.endangered
FROM species s
WHERE s.id = a.species_id;

ALTER TABLE species DROP COLUMN endangered;
ALTER TABLE species DROP COLUMN rare;

-- There is no longer any notion of a "project."
ALTER TABLE accession DROP COLUMN seedbank_project_id;
DROP TABLE seedbank_project;

-- There is no concept of accessions from the seed collector app needing to be reviewed.
ALTER TABLE accession DROP COLUMN needs_review;

-- While accessions created by the seed collector app will have a bunch of metadata filled in, the
-- UI allows creation of completely blank accessions with nothing filled in initially.
ALTER TABLE accession ALTER COLUMN app_device_id DROP NOT NULL;
ALTER TABLE accession ALTER COLUMN number DROP NOT NULL;
ALTER TABLE accession ALTER COLUMN species_id DROP NOT NULL;
ALTER TABLE accession ALTER COLUMN collection_site_location_id DROP NOT NULL;
ALTER TABLE accession ALTER COLUMN collected_date DROP NOT NULL;
ALTER TABLE accession ALTER COLUMN primary_collector_id DROP NOT NULL;

-- But since all the other timestamps are now nullable, we need to have some kind of timestamp
-- to do time-range-based queries (plus it's useful to track creation time in general).
ALTER TABLE accession ADD COLUMN created_time TIMESTAMP WITH TIME ZONE;

UPDATE accession a
SET created_time = (collected_date + TIME WITH TIME ZONE '00:00:00Z')
WHERE created_time IS NULL;

ALTER TABLE accession ALTER COLUMN created_time SET NOT NULL;

CREATE INDEX ON accession (created_time);

-- We need to be able to show the number of accessions that entered a particular state recently,
-- so keep a history of state changes.
CREATE TABLE accession_state_history (
    accession_id BIGINT REFERENCES accession NOT NULL,
    updated_time TIMESTAMP WITH TIME ZONE NOT NULL,
    old_state_id INTEGER REFERENCES accession_state,
    new_state_id INTEGER REFERENCES accession_state NOT NULL
);

COMMENT ON COLUMN accession_state_history.old_state_id
    IS 'Null if this is the initial state for a new accession.';
CREATE INDEX ON accession_state_history (accession_id);
CREATE INDEX ON accession_state_history (new_state_id, updated_time);

-- States are categorized as "active" or "inactive" status. Right now there are only two such
-- statuses so we'll use a boolean for simplicity. This replaces the "active" flag on the accession.
ALTER TABLE accession_state ADD COLUMN active BOOLEAN NOT NULL DEFAULT TRUE;
ALTER TABLE accession DROP COLUMN active;

-- Notifications have been completely revamped; they are now passive (no notion of delivery or of
-- destinations) and their state is shared by all users.
DROP TABLE notification_ack;
DROP TABLE notification_destination;
DROP TABLE notification_destination_type;
DROP TABLE notification;

CREATE TABLE notification_type (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    UNIQUE (name)
);

CREATE TABLE notification (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    site_id BIGINT NOT NULL REFERENCES site,
    type_id INTEGER NOT NULL REFERENCES notification_type,
    accession_id BIGINT REFERENCES accession,
    created_time TIMESTAMP WITH TIME ZONE NOT NULL,
    read BOOLEAN NOT NULL DEFAULT FALSE,
    message TEXT NOT NULL
);

COMMENT ON COLUMN notification.accession_id
    IS 'Null if this notification is not specific to a single accession.';

-- Storage locations have a "condition" value (refrigerator vs. freezer).
CREATE TABLE storage_condition (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    UNIQUE (name)
);
COMMENT ON TABLE storage_condition IS 'Refrigeration condition of seeds during storage.';

ALTER TABLE storage_location ADD COLUMN condition_id INTEGER REFERENCES storage_condition;
ALTER TABLE storage_location ALTER COLUMN condition_id SET NOT NULL;

-- Processing method is an enumerated value (counting vs. weighing).
CREATE TABLE processing_method (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    UNIQUE (name)
);
COMMENT ON TABLE processing_method IS 'Methods of counting seeds when processing accessions.';

ALTER TABLE accession ADD COLUMN processing_method_id INTEGER REFERENCES processing_method;

-- Make it explicit that viability test results in the accession table refer to cut tests. In the
-- future it's possible we'll want to move this to its own child table to account for multiple
-- viability test types, but for now leave it on the accession table.
ALTER TABLE accession RENAME COLUMN test_seeds_compromised TO cut_test_seeds_compromised;
ALTER TABLE accession RENAME COLUMN test_seeds_empty TO cut_test_seeds_empty;
ALTER TABLE accession RENAME COLUMN test_seeds_filled TO cut_test_seeds_filled;

-- Withdrawals need to be searchable by seeds remaining; storing it explicitly is less complex
-- than deriving it from previous withdrawals as part of the database query.
ALTER TABLE withdrawal ADD COLUMN seeds_remaining INTEGER NOT NULL DEFAULT 0;

-- Germination test type (lab vs. nursery)
CREATE TABLE germination_test_type (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    UNIQUE (name)
);

-- Germination tests need to be modeled separately from germinations since lab tests can have
-- multiple germinations per test. Original data model combined the two.
DROP TABLE germination;

CREATE TABLE germination_test (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    accession_id BIGINT NOT NULL REFERENCES accession,
    test_type INTEGER REFERENCES germination_test_type NOT NULL,
    start_date DATE NOT NULL,
    seed_type_id BIGINT REFERENCES germination_seed_type,
    substrate_id BIGINT REFERENCES germination_substrate,
    treatment_id BIGINT REFERENCES germination_treatment,
    seeds_sown INTEGER,
    notes TEXT
);

-- Germinations are always modeled as their own child table. For nursery tests, the UI prevents the
-- user from entering multiple germinations for a single test, but for lab tests there can be many.
CREATE TABLE germination (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    test_id BIGINT NOT NULL REFERENCES germination_test,
    recording_date DATE NOT NULL,
    seeds_germinated INTEGER NOT NULL
);
