CREATE TABLE nursery.batch_details_history(
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    batch_id BIGINT NOT NULL REFERENCES nursery.batches ON DELETE CASCADE,
    version INTEGER NOT NULL,
    created_by BIGINT NOT NULL REFERENCES users,
    created_time TIMESTAMP WITH TIME ZONE NOT NULL,
    notes TEXT,
    ready_by_date DATE,
    project_id BIGINT REFERENCES projects ON DELETE SET NULL,
    project_name TEXT,
    substrate_id INTEGER REFERENCES nursery.batch_substrates,
    substrate_notes TEXT,
    treatment_id INTEGER REFERENCES seed_treatments,
    treatment_notes TEXT,

    UNIQUE (batch_id, version)
);

CREATE INDEX ON nursery.batch_details_history (created_by);
CREATE INDEX ON nursery.batch_details_history (project_id);

CREATE TABLE nursery.batch_details_history_sub_locations (
    batch_details_history_id BIGINT NOT NULL REFERENCES nursery.batch_details_history ON DELETE CASCADE,
    sub_location_id BIGINT REFERENCES sub_locations ON DELETE SET NULL,
    sub_location_name TEXT NOT NULL,

    PRIMARY KEY (batch_details_history_id, sub_location_id)
);

CREATE INDEX ON nursery.batch_details_history_sub_locations (sub_location_id);

-- Backfill initial values for existing batches. Use a version number of 1 on the assumption that
-- most version number bumps are from quantity changes and the details are less likely to have
-- changed since batch creation. This will hopefully be right more often than it's wrong.
WITH history_insert AS (
    INSERT INTO nursery.batch_details_history (
            batch_id, version, created_by, created_time, notes, ready_by_date, project_id,
            project_name, substrate_id, substrate_notes, treatment_id, treatment_notes)
    SELECT b.id, 1, b.created_by, b.created_time, b.notes, b.ready_by_date, b.project_id,
           p.name, b.substrate_id, b.substrate_notes, b.treatment_id, b.treatment_notes
    FROM nursery.batches b
    LEFT JOIN projects p ON b.project_id = p.id
    RETURNING id, batch_id
)
INSERT INTO nursery.batch_details_history_sub_locations (
    batch_details_history_id, sub_location_id, sub_location_name)
SELECT hi.id, bsl.sub_location_id, sl.name
FROM history_insert hi
JOIN nursery.batch_sub_locations bsl ON hi.batch_id = bsl.batch_id
JOIN sub_locations sl ON bsl.sub_location_id = sl.id;

ALTER TABLE nursery.batch_quantity_history ADD COLUMN version INTEGER;

-- This is going to be an approximation and won't skip over version numbers that didn't involve
-- quantity changes, but it's the best we can do and should suffice for history sorting.
WITH version_numbers AS (
    SELECT id, RANK() OVER (PARTITION BY batch_id ORDER BY id) AS version
    FROM nursery.batch_quantity_history
)
UPDATE nursery.batch_quantity_history h
SET version = version_numbers.version
FROM version_numbers
WHERE h.id = version_numbers.id;

ALTER TABLE nursery.batch_quantity_history ALTER COLUMN version SET NOT NULL;
ALTER TABLE nursery.batch_quantity_history ADD UNIQUE (batch_id, version);
