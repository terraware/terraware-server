package com.terraformation.backend.email

import com.terraformation.backend.config.TerrawareServerConfig
import java.io.ByteArrayOutputStream
import javax.annotation.ManagedBean
import javax.mail.Message
import javax.mail.internet.MimeMessage
import org.springframework.mail.javamail.JavaMailSender
import software.amazon.awssdk.core.SdkBytes
import software.amazon.awssdk.services.sesv2.SesV2Client
import software.amazon.awssdk.services.sesv2.model.Destination
import software.amazon.awssdk.services.sesv2.model.EmailContent
import software.amazon.awssdk.services.sesv2.model.RawMessage

/**
 * Handles interacting with the email service specified by the server configuration.
 *
 * This is a facade for [JavaMailSender] or the AWS SES client, depending on which one is selected.
 */
@ManagedBean
class EmailSender(
    private val config: TerrawareServerConfig,
    private val javaMailSender: JavaMailSender,
) {
  /**
   * SES client. Only initialized if SES is enabled, since creating it loads AWS credentials that
   * may not be present in a dev environment.
   */
  private lateinit var sesClient: SesV2Client

  init {
    if (config.email.enabled && config.email.useSes) {
      sesClient = SesV2Client.create()
    }
  }

  fun createMimeMessage(): MimeMessage = javaMailSender.createMimeMessage()

  /**
   * Sends a message using the configured email service.
   *
   * @return The message ID generated by the email service, or null if the service did not return an
   * ID. This should be treated as an opaque value.
   */
  fun send(message: MimeMessage): String? {
    if (!config.email.enabled) {
      throw IllegalStateException("Email sending is disabled")
    }

    return if (config.email.useSes) {
      sendSes(message)
    } else {
      sendSmtp(message)
    }
  }

  /** Sends the message using the SES SendEmail API. */
  private fun sendSes(message: MimeMessage): String? {
    val rawMessage =
        ByteArrayOutputStream().use { stream ->
          message.writeTo(stream)
          stream.toByteArray()
        }

    val sdkBytes = SdkBytes.fromByteArrayUnsafe(rawMessage)
    val sender =
        message.from?.getOrNull(0)?.toString()
            ?: throw IllegalArgumentException("No sender address specified")

    val response =
        sesClient.sendEmail { builder ->
          builder.fromEmailAddress(sender)
          builder.destination(
              Destination.builder()
                  .toAddresses(message.getRecipientsString(Message.RecipientType.TO))
                  .ccAddresses(message.getRecipientsString(Message.RecipientType.CC))
                  .bccAddresses(message.getRecipientsString(Message.RecipientType.BCC))
                  .build(),
          )
          builder.content(
              EmailContent.builder().raw(RawMessage.builder().data(sdkBytes).build()).build())
        }

    return response.messageId()
  }

  /** Sends the message using SMTP. */
  private fun sendSmtp(message: MimeMessage): String? {
    javaMailSender.send(message)
    return message.messageID
  }
}
