package com.terraformation.backend.email

import com.terraformation.backend.config.TerrawareServerConfig
import com.terraformation.backend.customer.db.FacilityStore
import com.terraformation.backend.customer.db.OrganizationStore
import com.terraformation.backend.customer.db.ParentStore
import com.terraformation.backend.customer.db.ProjectStore
import com.terraformation.backend.customer.db.UserStore
import com.terraformation.backend.customer.event.AccessionDryingEndEvent
import com.terraformation.backend.customer.event.AccessionGerminationTestEvent
import com.terraformation.backend.customer.event.AccessionMoveToDryEvent
import com.terraformation.backend.customer.event.AccessionWithdrawalEvent
import com.terraformation.backend.customer.event.FacilityAlertRequestedEvent
import com.terraformation.backend.customer.event.FacilityIdleEvent
import com.terraformation.backend.customer.event.UserAddedToOrganizationEvent
import com.terraformation.backend.customer.event.UserAddedToProjectEvent
import com.terraformation.backend.customer.model.IndividualUser
import com.terraformation.backend.customer.model.requirePermissions
import com.terraformation.backend.db.AccessionId
import com.terraformation.backend.db.FacilityNotFoundException
import com.terraformation.backend.db.GerminationTestType
import com.terraformation.backend.db.OrganizationId
import com.terraformation.backend.db.OrganizationNotFoundException
import com.terraformation.backend.db.ProjectId
import com.terraformation.backend.db.ProjectNotFoundException
import com.terraformation.backend.db.UserNotFoundException
import com.terraformation.backend.db.tables.daos.OrganizationsDao
import com.terraformation.backend.email.model.AccessionDryingEnd
import com.terraformation.backend.email.model.AccessionGerminationTest
import com.terraformation.backend.email.model.AccessionMoveToDry
import com.terraformation.backend.email.model.AccessionWithdrawal
import com.terraformation.backend.email.model.FacilityAlertRequested
import com.terraformation.backend.email.model.FacilityIdle
import com.terraformation.backend.email.model.UserAddedToOrganization
import com.terraformation.backend.email.model.UserAddedToProject
import com.terraformation.backend.i18n.Messages
import com.terraformation.backend.log.perClassLogger
import javax.annotation.ManagedBean
import org.springframework.context.event.EventListener

@ManagedBean
class EmailNotificationService(
    private val config: TerrawareServerConfig,
    private val emailService: EmailService,
    private val facilityStore: FacilityStore,
    private val messages: Messages,
    private val organizationsDao: OrganizationsDao,
    private val organizationStore: OrganizationStore,
    private val parentStore: ParentStore,
    private val projectStore: ProjectStore,
    private val userStore: UserStore,
    private val webAppUrls: WebAppUrls,
) {
  private val log = perClassLogger()

  /**
   * Sends a client-supplied alert about a facility. These alerts are typically generated by the
   * device manager.
   */
  @EventListener
  fun on(event: FacilityAlertRequestedEvent) {
    val requestedByUser =
        userStore.fetchById(event.requestedBy)
            ?: throw IllegalArgumentException("Alert requested by nonexistent user")
    requirePermissions(requestedByUser) { sendAlert(event.facilityId) }

    log.info(
        "Alert for facility ${event.facilityId} requested by user ${requestedByUser.userId} " +
            "(${requestedByUser.email})")
    log.info("Alert subject: ${event.subject}")
    log.info("Alert body: ${event.body}")

    val facility =
        facilityStore.fetchById(event.facilityId)
            ?: throw FacilityNotFoundException(event.facilityId)

    emailService.sendFacilityNotification(
        event.facilityId,
        "facilityAlert",
        FacilityAlertRequested(config, event.body, facility, requestedByUser, event.subject))
  }

  @EventListener
  fun on(event: FacilityIdleEvent) {
    val facility =
        facilityStore.fetchById(event.facilityId)
            ?: throw FacilityNotFoundException(event.facilityId)

    emailService.sendFacilityNotification(
        facility.id,
        "facilityIdle",
        FacilityIdle(config, facility, messages.dateAndTime(facility.lastTimeseriesTime)))
  }

  @EventListener
  fun on(event: UserAddedToOrganizationEvent) {
    val admin = userStore.fetchById(event.addedBy) ?: throw UserNotFoundException(event.addedBy)
    val user = userStore.fetchById(event.userId) ?: throw UserNotFoundException(event.userId)
    val organization =
        organizationStore.fetchById(event.organizationId)
            ?: throw OrganizationNotFoundException(event.organizationId)

    val organizationHomeUrl = webAppUrls.fullOrganizationHome(event.organizationId).toString()

    emailService.sendUserNotification(
        user,
        "userAddedToOrganization",
        UserAddedToOrganization(config, admin, organization, organizationHomeUrl),
        requireOptIn = false)
  }

  @EventListener
  fun on(event: UserAddedToProjectEvent) {
    val admin = userStore.fetchById(event.addedBy) ?: throw UserNotFoundException(event.addedBy)
    val user = userStore.fetchById(event.userId) ?: throw UserNotFoundException(event.userId)
    val project =
        projectStore.fetchById(event.projectId) ?: throw ProjectNotFoundException(event.projectId)
    val organization =
        organizationStore.fetchById(project.organizationId)
            ?: throw OrganizationNotFoundException(project.organizationId)

    val organizationProjectUrl =
        webAppUrls.fullOrganizationProject(event.projectId, project.organizationId).toString()

    emailService.sendUserNotification(
        user,
        "userAddedToProject",
        UserAddedToProject(config, admin, project, organization, organizationProjectUrl))
  }

  @EventListener
  fun on(event: AccessionMoveToDryEvent) {
    val organizationId = getOrganizationId(event.accessionId)
    val organization =
        organizationsDao.fetchOneById(organizationId)
            ?: throw OrganizationNotFoundException(organizationId)
    val accessionUrl = webAppUrls.fullAccession(event.accessionId, organizationId).toString()
    getRecipients(event.accessionId).forEach { user ->
      emailService.sendUserNotification(
          user,
          "accessionMoveToDry",
          AccessionMoveToDry(config, event.accessionNumber, organization, accessionUrl))
    }
  }

  @EventListener
  fun on(event: AccessionDryingEndEvent) {
    val organizationId = getOrganizationId(event.accessionId)
    val organization =
        organizationsDao.fetchOneById(organizationId)
            ?: throw OrganizationNotFoundException(organizationId)
    val accessionUrl = webAppUrls.fullAccession(event.accessionId, organizationId).toString()
    getRecipients(event.accessionId).forEach { user ->
      emailService.sendUserNotification(
          user,
          "accessionDryingEnd",
          AccessionDryingEnd(config, event.accessionNumber, organization, accessionUrl))
    }
  }

  @EventListener
  fun on(event: AccessionGerminationTestEvent) {
    val organizationId = getOrganizationId(event.accessionId)
    val organization =
        organizationsDao.fetchOneById(organizationId)
            ?: throw OrganizationNotFoundException(organizationId)
    val accessionUrl =
        webAppUrls
            .fullAccessionGerminationTest(event.accessionId, event.testType, organizationId)
            .toString()
    val testType =
        when (event.testType) {
          GerminationTestType.Lab -> "lab"
          GerminationTestType.Nursery -> "nursery"
        }
    getRecipients(event.accessionId).forEach { user ->
      emailService.sendUserNotification(
          user,
          "accessionGerminationTest",
          AccessionGerminationTest(
              config, event.accessionNumber, testType, organization, accessionUrl))
    }
  }

  @EventListener
  fun on(event: AccessionWithdrawalEvent) {
    val organizationId = getOrganizationId(event.accessionId)
    val organization =
        organizationsDao.fetchOneById(organizationId)
            ?: throw OrganizationNotFoundException(organizationId)
    val accessionUrl = webAppUrls.fullAccession(event.accessionId, organizationId).toString()
    getRecipients(event.accessionId).forEach { user ->
      emailService.sendUserNotification(
          user,
          "accessionWithdrawal",
          AccessionWithdrawal(config, event.accessionNumber, organization, accessionUrl))
    }
  }

  private fun getProjectId(accessionId: AccessionId): ProjectId {
    val facilityId = parentStore.getFacilityId(accessionId)!!
    return parentStore.getProjectId(facilityId)!!
  }

  private fun getOrganizationId(accessionId: AccessionId): OrganizationId {
    return parentStore.getOrganizationId(getProjectId(accessionId))!!
  }

  private fun getRecipients(accessionId: AccessionId): List<IndividualUser> {
    return projectStore.fetchEmailRecipients(getProjectId(accessionId)).toSet().mapNotNull {
      userStore.fetchByEmail(it)
    }
  }
}
