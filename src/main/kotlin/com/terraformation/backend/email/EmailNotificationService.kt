package com.terraformation.backend.email

import com.terraformation.backend.config.TerrawareServerConfig
import com.terraformation.backend.customer.db.FacilityStore
import com.terraformation.backend.customer.db.OrganizationStore
import com.terraformation.backend.customer.db.ParentStore
import com.terraformation.backend.customer.db.ProjectStore
import com.terraformation.backend.customer.db.UserStore
import com.terraformation.backend.customer.event.FacilityAlertRequestedEvent
import com.terraformation.backend.customer.event.FacilityIdleEvent
import com.terraformation.backend.customer.event.UserAddedToOrganizationEvent
import com.terraformation.backend.customer.event.UserAddedToProjectEvent
import com.terraformation.backend.customer.model.IndividualUser
import com.terraformation.backend.customer.model.requirePermissions
import com.terraformation.backend.db.AccessionId
import com.terraformation.backend.db.AccessionNotFoundException
import com.terraformation.backend.db.FacilityId
import com.terraformation.backend.db.FacilityNotFoundException
import com.terraformation.backend.db.GerminationTestType
import com.terraformation.backend.db.OrganizationNotFoundException
import com.terraformation.backend.db.ProjectNotFoundException
import com.terraformation.backend.db.UserNotFoundException
import com.terraformation.backend.db.tables.daos.OrganizationsDao
import com.terraformation.backend.db.tables.pojos.OrganizationsRow
import com.terraformation.backend.email.model.AccessionDryingEnd
import com.terraformation.backend.email.model.AccessionGerminationTest
import com.terraformation.backend.email.model.AccessionMoveToDry
import com.terraformation.backend.email.model.AccessionWithdrawal
import com.terraformation.backend.email.model.AccessionsAwaitingProcessing
import com.terraformation.backend.email.model.AccessionsFinishedDrying
import com.terraformation.backend.email.model.AccessionsReadyForTesting
import com.terraformation.backend.email.model.EmailTemplateModel
import com.terraformation.backend.email.model.FacilityAlertRequested
import com.terraformation.backend.email.model.FacilityIdle
import com.terraformation.backend.email.model.UserAddedToOrganization
import com.terraformation.backend.email.model.UserAddedToProject
import com.terraformation.backend.log.perClassLogger
import com.terraformation.backend.seedbank.daily.DateNotificationTask
import com.terraformation.backend.seedbank.daily.StateSummaryNotificationTask
import com.terraformation.backend.seedbank.event.AccessionDryingEndEvent
import com.terraformation.backend.seedbank.event.AccessionGerminationTestEvent
import com.terraformation.backend.seedbank.event.AccessionMoveToDryEvent
import com.terraformation.backend.seedbank.event.AccessionWithdrawalEvent
import com.terraformation.backend.seedbank.event.AccessionsAwaitingProcessingEvent
import com.terraformation.backend.seedbank.event.AccessionsFinishedDryingEvent
import com.terraformation.backend.seedbank.event.AccessionsReadyForTestingEvent
import javax.annotation.ManagedBean
import org.springframework.context.event.EventListener

@ManagedBean
class EmailNotificationService(
    private val config: TerrawareServerConfig,
    private val emailService: EmailService,
    private val facilityStore: FacilityStore,
    private val organizationsDao: OrganizationsDao,
    private val organizationStore: OrganizationStore,
    private val parentStore: ParentStore,
    private val projectStore: ProjectStore,
    private val userStore: UserStore,
    private val webAppUrls: WebAppUrls,
) {
  private val log = perClassLogger()
  private val accessionDatePendingEmails: MutableList<EmailRequest> = mutableListOf()
  private val accessionStatePendingEmails: MutableList<EmailRequest> = mutableListOf()

  /**
   * Sends a client-supplied alert about a facility. These alerts are typically generated by the
   * device manager.
   */
  @EventListener
  fun on(event: FacilityAlertRequestedEvent) {
    val requestedByUser =
        userStore.fetchById(event.requestedBy)
            ?: throw IllegalArgumentException("Alert requested by nonexistent user")
    requirePermissions(requestedByUser) { sendAlert(event.facilityId) }

    log.info(
        "Alert for facility ${event.facilityId} requested by user ${requestedByUser.userId} " +
            "(${requestedByUser.email})")
    log.info("Alert subject: ${event.subject}")
    log.info("Alert body: ${event.body}")

    val facility =
        facilityStore.fetchById(event.facilityId)
            ?: throw FacilityNotFoundException(event.facilityId)

    emailService.sendFacilityNotification(
        event.facilityId,
        FacilityAlertRequested(config, event.body, facility, requestedByUser, event.subject))
  }

  @EventListener
  fun on(event: FacilityIdleEvent) {
    val facility =
        facilityStore.fetchById(event.facilityId)
            ?: throw FacilityNotFoundException(event.facilityId)

    val facilityMonitoringUrl =
        webAppUrls
            .fullFacilityMonitoring(
                parentStore.getOrganizationId(event.facilityId)!!, event.facilityId)
            .toString()
    emailService.sendFacilityNotification(
        facility.id, FacilityIdle(config, facility, facilityMonitoringUrl))
  }

  @EventListener
  fun on(event: UserAddedToOrganizationEvent) {
    val admin = userStore.fetchById(event.addedBy) ?: throw UserNotFoundException(event.addedBy)
    val user = userStore.fetchById(event.userId) ?: throw UserNotFoundException(event.userId)
    val organization =
        organizationStore.fetchById(event.organizationId)
            ?: throw OrganizationNotFoundException(event.organizationId)

    val organizationHomeUrl = webAppUrls.fullOrganizationHome(event.organizationId).toString()

    emailService.sendUserNotification(
        user,
        UserAddedToOrganization(config, admin, organization, organizationHomeUrl),
        requireOptIn = false)
  }

  @EventListener
  fun on(event: UserAddedToProjectEvent) {
    val admin = userStore.fetchById(event.addedBy) ?: throw UserNotFoundException(event.addedBy)
    val user = userStore.fetchById(event.userId) ?: throw UserNotFoundException(event.userId)
    val project =
        projectStore.fetchById(event.projectId) ?: throw ProjectNotFoundException(event.projectId)
    val organization =
        organizationStore.fetchById(project.organizationId)
            ?: throw OrganizationNotFoundException(project.organizationId)

    val organizationProjectUrl =
        webAppUrls.fullOrganizationProject(event.projectId, project.organizationId).toString()

    emailService.sendUserNotification(
        user, UserAddedToProject(config, admin, project, organization, organizationProjectUrl))
  }

  @EventListener
  fun on(event: AccessionMoveToDryEvent) {
    val organizationId = parentStore.getOrganizationId(event.accessionId)
    val facilityName = parentStore.getFacilityName(event.accessionId)
    val accessionUrl = webAppUrls.fullAccession(event.accessionId, organizationId).toString()
    getRecipients(event.accessionId).forEach { user ->
      accessionDatePendingEmails.add(
          EmailRequest(
              user, AccessionMoveToDry(config, event.accessionNumber, facilityName, accessionUrl)))
    }
  }

  @EventListener
  fun on(event: AccessionDryingEndEvent) {
    val organizationId = parentStore.getOrganizationId(event.accessionId)
    val facilityName = parentStore.getFacilityName(event.accessionId)
    val accessionUrl = webAppUrls.fullAccession(event.accessionId, organizationId).toString()
    getRecipients(event.accessionId).forEach { user ->
      accessionDatePendingEmails.add(
          EmailRequest(
              user, AccessionDryingEnd(config, event.accessionNumber, facilityName, accessionUrl)))
    }
  }

  @EventListener
  fun on(event: AccessionGerminationTestEvent) {
    val organizationId = parentStore.getOrganizationId(event.accessionId)
    val facilityName = parentStore.getFacilityName(event.accessionId)
    val accessionUrl =
        webAppUrls
            .fullAccessionGerminationTest(event.accessionId, event.testType, organizationId)
            .toString()
    val testType =
        when (event.testType) {
          GerminationTestType.Lab -> "lab"
          GerminationTestType.Nursery -> "nursery"
        }
    getRecipients(event.accessionId).forEach { user ->
      accessionDatePendingEmails.add(
          EmailRequest(
              user,
              AccessionGerminationTest(
                  config, event.accessionNumber, testType, facilityName, accessionUrl)))
    }
  }

  @EventListener
  fun on(event: AccessionWithdrawalEvent) {
    val organizationId = parentStore.getOrganizationId(event.accessionId)
    val facilityName = parentStore.getFacilityName(event.accessionId)
    val accessionUrl = webAppUrls.fullAccession(event.accessionId, organizationId).toString()
    getRecipients(event.accessionId).forEach { user ->
      accessionDatePendingEmails.add(
          EmailRequest(
              user, AccessionWithdrawal(config, event.accessionNumber, facilityName, accessionUrl)))
    }
  }

  @EventListener
  fun on(event: AccessionsAwaitingProcessingEvent) {
    val organization = getOrganization(event.facilityId)
    val accessionsUrl =
        webAppUrls.fullAccessions(organization.id!!, event.facilityId, event.state).toString()
    getRecipients(event.facilityId).forEach { user ->
      accessionStatePendingEmails.add(
          EmailRequest(
              user,
              AccessionsAwaitingProcessing(
                  config, event.numAccessions, organization.name!!, accessionsUrl)))
    }
  }

  @EventListener
  fun on(event: AccessionsReadyForTestingEvent) {
    val organization = getOrganization(event.facilityId)
    val accessionsUrl =
        webAppUrls.fullAccessions(organization.id!!, event.facilityId, event.state).toString()
    getRecipients(event.facilityId).forEach { user ->
      accessionStatePendingEmails.add(
          EmailRequest(
              user,
              AccessionsReadyForTesting(
                  config, event.numAccessions, event.weeks, organization.name!!, accessionsUrl)))
    }
  }

  @EventListener
  fun on(event: AccessionsFinishedDryingEvent) {
    val organization = getOrganization(event.facilityId)
    val accessionsUrl =
        webAppUrls.fullAccessions(organization.id!!, event.facilityId, event.state).toString()
    getRecipients(event.facilityId).forEach { user ->
      accessionStatePendingEmails.add(
          EmailRequest(
              user,
              AccessionsFinishedDrying(
                  config, event.numAccessions, organization.name!!, accessionsUrl)))
    }
  }

  @EventListener
  fun on(@Suppress("UNUSED_PARAMETER") event: DateNotificationTask.StartedEvent) {
    accessionDatePendingEmails.clear()
  }

  @EventListener
  fun on(@Suppress("UNUSED_PARAMETER") event: DateNotificationTask.SucceededEvent) {
    accessionDatePendingEmails.forEach { sendEmail(it) }
    accessionDatePendingEmails.clear()
  }

  @EventListener
  fun on(@Suppress("UNUSED_PARAMETER") event: DateNotificationTask.FinishedEvent) {
    accessionDatePendingEmails.clear()
  }

  @EventListener
  fun on(@Suppress("UNUSED_PARAMETER") event: StateSummaryNotificationTask.StartedEvent) {
    accessionStatePendingEmails.clear()
  }

  @EventListener
  fun on(@Suppress("UNUSED_PARAMETER") event: StateSummaryNotificationTask.SucceededEvent) {
    accessionStatePendingEmails.forEach { sendEmail(it) }
    accessionStatePendingEmails.clear()
  }

  @EventListener
  fun on(@Suppress("UNUSED_PARAMETER") event: StateSummaryNotificationTask.FinishedEvent) {
    accessionStatePendingEmails.clear()
  }

  private fun sendEmail(emailRequest: EmailRequest) {
    with(emailRequest) {
      try {
        emailService.sendUserNotification(user, emailTemplateModel)
      } catch (e: Exception) {
        log.error("Error sending email ${emailTemplateModel.templateDir} to user ${user.email}", e)
      }
    }
  }

  private fun getOrganization(facilityId: FacilityId): OrganizationsRow {
    val organizationId =
        parentStore.getOrganizationId(facilityId) ?: throw FacilityNotFoundException(facilityId)
    return organizationsDao.fetchOneById(organizationId)
        ?: throw OrganizationNotFoundException(organizationId)
  }

  private fun getRecipients(accessionId: AccessionId): List<IndividualUser> {
    val facilityId =
        parentStore.getFacilityId(accessionId) ?: throw AccessionNotFoundException(accessionId)
    return getRecipients(facilityId)
  }

  private fun getRecipients(facilityId: FacilityId): List<IndividualUser> {
    val projectId =
        parentStore.getProjectId(facilityId) ?: throw FacilityNotFoundException(facilityId)
    return projectStore.fetchEmailRecipients(projectId).mapNotNull { userStore.fetchByEmail(it) }
  }

  data class EmailRequest(val user: IndividualUser, val emailTemplateModel: EmailTemplateModel)
}
