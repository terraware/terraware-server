package com.terraformation.backend.customer.model

import com.terraformation.backend.auth.CurrentUserHolder
import com.terraformation.backend.auth.currentUser
import com.terraformation.backend.db.accelerator.DeliverableId
import com.terraformation.backend.db.default_schema.FacilityId
import com.terraformation.backend.db.default_schema.GlobalRole
import com.terraformation.backend.db.default_schema.OrganizationId
import com.terraformation.backend.db.default_schema.ProjectId
import com.terraformation.backend.db.default_schema.Role
import com.terraformation.backend.db.default_schema.SeedFundReportId
import com.terraformation.backend.db.default_schema.UserId
import com.terraformation.backend.db.default_schema.UserType
import com.terraformation.backend.db.default_schema.tables.daos.UsersDao
import jakarta.inject.Named
import java.time.ZoneId
import java.time.ZoneOffset
import org.springframework.context.annotation.Lazy

/**
 * Internal-use-only identity for automated tasks that aren't on behalf of a specific individual
 * user.
 *
 * This is needed because automated tasks can perform operations that need to be attributed to a
 * user, e.g., modifying accession data. We want to keep track of the fact that those operations
 * were initiated by the system itself rather than by a human user or an API client. In addition,
 * automated tasks need to call application code that has permission checks, which means there needs
 * to be a [currentUser] defined.
 *
 * This user is analogous to the "root" user on UNIX systems in that it always has permission to do
 * everything. However, it doesn't belong to any organizations or projects, and it is an error to
 * try to perform operations that depend on enumerating the current user's organization or project
 * memberships.
 *
 * There is no way for a client to authenticate as the system user; the application code has to
 * explicitly switch to this user identity, typically by calling this class's [run] method.
 */
@Named
class SystemUser(
    // This class is instantiated as a dependency when we're generating docs, and thus don't have a
    // database to connect to. In that case we will never actually need to query the system user's
    // ID, so the UsersDao proxy that's generated by @Lazy will never need a real DAO, which means
    // we will never need the database context that's passed as a dependency to DAO classes.
    @Lazy usersDao: UsersDao
) : TerrawareUser {
  companion object {
    /**
     * The system user's username (email address) in the users table. This is used to look up the
     * system user's user ID.
     */
    const val USERNAME = "system"
    private const val EMAIL = "systemUser@terraformation.com"
  }

  override val description: String
    get() = "system user"

  override val timeZone: ZoneId
    get() = ZoneOffset.UTC

  override val userId: UserId by lazy {
    usersDao.fetchOneByEmail(USERNAME)?.id
        ?: throw IllegalStateException("Unable to find user: $USERNAME")
  }

  override val userType: UserType
    get() = UserType.System

  override val authId: String?
    get() = null

  override val email
    get() = EMAIL

  /*
   * The system user has no roles per se; it always has access to everything. Reject any attempts to
   * walk the current user's list of roles.
   *
   * If at some point we write code that needs to run as the system user and really needs a full
   * enumerated list of roles, it will be possible to change these methods to dump out the full list
   * of organizations/projects/etc. But it'll probably be better to solve the problem some other way
   * in that case, given that those lists will grow large over time.
   */

  override val organizationRoles: Map<OrganizationId, Role>
    get() {
      throw NotImplementedError("System user does not support enumerating roles")
    }

  override val facilityRoles: Map<FacilityId, Role>
    get() {
      throw NotImplementedError("System user does not support enumerating roles")
    }

  override val globalRoles: Set<GlobalRole>
    get() = emptySet()

  override val defaultPermission: Boolean
    get() = true

  override fun <T> run(func: () -> T): T {
    return CurrentUserHolder.runAs(this, func)
  }

  override fun hasAnyAdminRole(): Boolean = true

  override fun getUsername(): String = USERNAME

  override fun getName(): String = USERNAME

  /*
   * All permission checks always succeed (thanks to defaultPermission) except for operations that
   * should only be performed manually by a system administrator.
   */
  override fun canAcceptCurrentDisclaimer() = false

  override fun canDeleteSeedFundReport(reportId: SeedFundReportId): Boolean = false

  override fun canDeleteSelf(): Boolean = false

  override fun canDeleteUsers(): Boolean = false

  override fun canImportGlobalSpeciesData(): Boolean = false

  override fun canManageDeliverables(): Boolean = false

  override fun canManageDocumentProducer(): Boolean = false

  override fun canManageInternalTags(): Boolean = false

  override fun canManageModuleEvents(): Boolean = false

  override fun canManageModules(): Boolean = false

  override fun canRegenerateAllDeviceManagerTokens(): Boolean = false

  override fun canUpdateProjectDocumentSettings(projectId: ProjectId): Boolean = false

  override fun canUpdateSubmissionStatus(
      deliverableId: DeliverableId,
      projectId: ProjectId,
  ): Boolean = false
}
