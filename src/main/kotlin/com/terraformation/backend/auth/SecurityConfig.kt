package com.terraformation.backend.auth

import com.terraformation.backend.VERSION
import com.terraformation.backend.customer.db.UserStore
import org.springframework.context.annotation.Bean
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.config.web.servlet.invoke
import org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper
import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationProvider
import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationToken
import org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter
import org.springframework.security.web.header.writers.StaticHeadersWriter
import org.springframework.web.cors.CorsConfiguration
import org.springframework.web.cors.CorsConfigurationSource
import org.springframework.web.cors.UrlBasedCorsConfigurationSource

/**
 * Configures Spring Security to authenticate incoming requests.
 *
 * You probably don't need to mess with any of this. In the application code, you can call
 * [currentUser] to get the currently logged-in user's details.
 *
 * However, in case you do need to mess with this, or are just curious:
 *
 * The way authentication works in terraware-server is a little unusual. The server sits behind
 * OAuth2-Proxy, which takes care of redirecting users to a login page or rejecting unauthenticated
 * API requests. Any requests the proxy forwards to terraware-server are thus already authenticated,
 * and the proxy includes HTTP headers to identify the authenticated user.
 *
 * As a result, we don't really use much of the typical Spring Security infrastructure such as
 * session management and password checking; all that stuff happens before requests get here. In
 * Spring Security terms, our requests are all pre-authenticated.
 *
 * The Spring Security docs have a lot more detail about the exact flow, but there are a couple
 * pertinent moving parts to know about if you need to work with this code.
 *
 * - The request passes through the servlet filter created by [oauth2ProxyFilter]. That filter pulls
 * the user ID from OAuth2-Proxy out of the incoming request's headers and uses it as the principal
 * name. The user ID is a UUID that is generated by Keycloak when a new user registers.
 *
 * - We configure an authentication manager to use our [UserStore] to look up user details. They're
 * looked up by the UUID we get from the HTTP header. If the user doesn't exist yet, [UserStore]
 * fetches their information from Keycloak and adds them to the local database.
 */
@EnableWebSecurity
class SecurityConfig(private val userStore: UserStore) : WebSecurityConfigurerAdapter() {

  override fun configure(http: HttpSecurity) {
    http.addFilter(oauth2ProxyFilter())

    http {
      cors {}
      csrf { disable() }
      authorizeRequests { authorize("/api/**", fullyAuthenticated) }
      httpBasic {}
      sessionManagement { sessionCreationPolicy = SessionCreationPolicy.STATELESS }

      // This has nothing to do with security, but Spring Security supports adding custom headers.
      headers { addHeaderWriter(StaticHeadersWriter("Server", "Terraware-Server/$VERSION")) }
    }
  }

  override fun configure(auth: AuthenticationManagerBuilder) {
    auth.authenticationProvider(preAuthenticatedAuthenticationProvider())
    auth.userDetailsService(userStore)
  }

  private fun oauth2ProxyFilter(): RequestHeaderAuthenticationFilter {
    val authFilter = RequestHeaderAuthenticationFilter()
    authFilter.setPrincipalRequestHeader(OAUTH2_PROXY_USER_ID_HEADER_NAME)
    authFilter.setAuthenticationManager(authenticationManager())
    authFilter.setExceptionIfHeaderMissing(false)
    return authFilter
  }

  @Bean
  fun corsConfigurationSource(): CorsConfigurationSource {
    val configuration = CorsConfiguration().applyPermitDefaultValues()
    val source = UrlBasedCorsConfigurationSource()
    configuration.allowedMethods = listOf("*")
    source.registerCorsConfiguration("/**", configuration)
    return source
  }

  @Bean
  fun userDetailsByNameServiceWrapper():
      UserDetailsByNameServiceWrapper<PreAuthenticatedAuthenticationToken> {
    return UserDetailsByNameServiceWrapper<PreAuthenticatedAuthenticationToken>(userStore)
  }

  @Bean
  fun preAuthenticatedAuthenticationProvider(): PreAuthenticatedAuthenticationProvider {
    val provider = PreAuthenticatedAuthenticationProvider()
    provider.setPreAuthenticatedUserDetailsService(userDetailsByNameServiceWrapper())
    return provider
  }
}
