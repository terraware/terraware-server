package com.terraformation.backend.file.mux

import MuxApiStatus
import MuxCreateVideoAssetRequestPayload
import MuxCreateVideoAssetResponsePayload
import com.terraformation.backend.config.TerrawareServerConfig
import com.terraformation.backend.customer.model.SystemUser
import com.terraformation.backend.db.default_schema.FileId
import com.terraformation.backend.db.default_schema.MuxAssetStatus
import com.terraformation.backend.db.default_schema.tables.references.MUX_ASSETS
import com.terraformation.backend.file.FileService
import com.terraformation.backend.file.VideoStreamNotFoundException
import com.terraformation.backend.file.event.VideoFileDeletedEvent
import com.terraformation.backend.file.event.VideoFileUploadedEvent
import com.terraformation.backend.log.perClassLogger
import io.jsonwebtoken.Jwts
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.plugins.ClientRequestException
import io.ktor.client.request.basicAuth
import io.ktor.client.request.request
import io.ktor.client.request.setBody
import io.ktor.client.statement.HttpResponse
import io.ktor.client.statement.bodyAsText
import io.ktor.http.HttpMethod
import io.ktor.http.HttpStatusCode
import jakarta.inject.Named
import java.io.StringReader
import java.net.URI
import java.security.KeyFactory
import java.security.PrivateKey
import java.security.spec.PKCS8EncodedKeySpec
import java.time.Duration
import java.time.InstantSource
import java.util.Base64
import java.util.Date
import kotlinx.coroutines.runBlocking
import org.bouncycastle.openssl.PEMKeyPair
import org.bouncycastle.openssl.PEMParser
import org.jobrunr.scheduling.JobScheduler
import org.jooq.DSLContext
import org.springframework.context.annotation.Lazy
import org.springframework.context.event.EventListener

@Named
class MuxService(
    private val clock: InstantSource,
    private val config: TerrawareServerConfig,
    private val dslContext: DSLContext,
    private val fileService: FileService,
    private val httpClient: HttpClient,
    @Lazy private val jobScheduler: JobScheduler,
    private val systemUser: SystemUser,
) {
  /**
   * How long to make files available for Mux to download. The files will have random URLs but will
   * be accessible without authentication for this amount of time; it should be long enough to let
   * Mux retry if there's a transient error.
   */
  private val fileAccessTokenExpiration = Duration.ofHours(24)

  /**
   * URL path prefix of the "download a file without authentication" endpoint. The file access token
   * generated by [FileService] will be added as a path element beneath this path.
   */
  private val fileAccessEndpoint = "/api/v1/files/tokens"

  private val muxApiUrl = URI("https://api.mux.com")

  private val log = perClassLogger()

  // Non-null copies of config values.
  private lateinit var tokenId: String
  private lateinit var tokenSecret: String
  private lateinit var signingKey: PrivateKey
  private lateinit var signingKeyId: String
  private lateinit var baseUrl: URI

  init {
    if (config.mux.enabled) {
      baseUrl = config.mux.externalUrl ?: config.webAppUrl
      signingKey = parseSigningKey()
      signingKeyId = config.mux.signingKeyId!!
      tokenId = config.mux.tokenId!!
      tokenSecret = config.mux.tokenSecret!!
    }
  }

  /**
   * Sends a video file to Mux for processing. At a high level, the flow is
   * 1. Generate a file access token that's good for some amount of time. See
   *    [FileService.createToken].
   * 2. Tell Mux to download the original file from us using that token and to create a playback
   *    configuration that requires a signed playback token.
   * 3. Record the Mux IDs (asset, playback) from that request.
   * 4. After Mux is done processing the file, it sends us a webhook request to indicate the result.
   * 5. Record the file's status (ready or errored).
   */
  fun sendFileToMux(fileId: FileId): String {
    ensureEnabled()

    // This gets called from a JobRunr job after a file is uploaded, so we need to set the current
    // user to attribute the token to since there won't be an active one.
    val token = systemUser.run { fileService.createToken(fileId, fileAccessTokenExpiration) }

    val request =
        MuxCreateVideoAssetRequestPayload(
            fileId = fileId,
            test = config.mux.useTestAssets,
            url = baseUrl.resolve("$fileAccessEndpoint/$token"),
        )
    val response = sendRequest<MuxCreateVideoAssetResponsePayload>("/video/v1/assets", request)

    if (response.data.status == MuxApiStatus.errored) {
      log.warn("File $fileId marked as errored at creation time: ${response.data.errorMessage}")
    }

    val playbackId = response.data.playbackId ?: throw IllegalStateException("No playback ID found")

    with(MUX_ASSETS) {
      dslContext
          .insertInto(MUX_ASSETS)
          .set(ASSET_ID, response.data.id)
          .set(CREATED_TIME, clock.instant())
          .set(ERROR_MESSAGE, response.data.errorMessage)
          .set(FILE_ID, fileId)
          .set(MUX_ASSET_STATUS_ID, response.data.status.assetStatus)
          .set(PLAYBACK_ID, playbackId)
          .execute()
    }

    return playbackId
  }

  /**
   * Returns information a client needs in order to configure a video player to stream a file from
   * Mux. For access control, this includes a time-limited playback token that expires.
   *
   * @param expiration How long the stream should be accessible. After this, clients will need to
   *   request a new playback token.
   */
  fun getMuxStream(
      fileId: FileId,
      expiration: Duration = Duration.ofSeconds(config.mux.streamExpirationSeconds),
  ): MuxStreamModel {
    ensureEnabled()

    val playbackId =
        dslContext.fetchValue(MUX_ASSETS.PLAYBACK_ID, MUX_ASSETS.FILE_ID.eq(fileId))
            ?: throw VideoStreamNotFoundException(fileId)
    val token =
        Jwts.builder()
            .subject(playbackId)
            .claim("kid", signingKeyId)
            .claim("aud", "v") // "v" = token is for video playback
            .expiration(Date(clock.instant().plus(expiration).toEpochMilli()))
            .signWith(signingKey)
            .compact()

    return MuxStreamModel(fileId = fileId, playbackId = playbackId, playbackToken = token)
  }

  fun markAssetReady(fileId: FileId) {
    with(MUX_ASSETS) {
      if (!dslContext.fetchExists(MUX_ASSETS, FILE_ID.eq(fileId))) {
        log.error("Got ready update for unknown file $fileId")
      } else {
        dslContext
            .update(MUX_ASSETS)
            .set(MUX_ASSET_STATUS_ID, MuxAssetStatus.Ready)
            .set(READY_TIME, clock.instant())
            .where(FILE_ID.eq(fileId))
            .and(READY_TIME.isNull)
            .execute()

        log.info("File $fileId marked as ready by Mux")
      }
    }
  }

  fun markAssetDeleted(fileId: FileId) {
    with(MUX_ASSETS) {
      // If the asset doesn't exist, ignore it; this will be the case if we've initiated the
      // deletion ourselves and we later get a callback from Mux notifying us of the deletion.
      if (dslContext.deleteFrom(MUX_ASSETS).where(FILE_ID.eq(fileId)).execute() == 1) {
        log.info("Asset for file $fileId deleted by Mux")
      }
    }
  }

  fun markAssetErrored(fileId: FileId, errorMessage: String?) {
    with(MUX_ASSETS) {
      if (!dslContext.fetchExists(MUX_ASSETS, FILE_ID.eq(fileId))) {
        log.error("Got error update for unknown file $fileId")
      } else {
        dslContext
            .update(MUX_ASSETS)
            .set(ERROR_MESSAGE, errorMessage)
            .set(MUX_ASSET_STATUS_ID, MuxAssetStatus.Errored)
            .where(FILE_ID.eq(fileId))
            .execute()

        log.warn("File $fileId marked as errored by Mux: $errorMessage")
      }
    }
  }

  /** Sends newly-uploaded video files to Mux if enabled. This is done asynchronously. */
  @EventListener
  fun on(event: VideoFileUploadedEvent) {
    if (config.mux.enabled) {
      jobScheduler.enqueue<MuxService> { sendFileToMux(event.fileId) }
    }
  }

  @EventListener
  fun on(event: VideoFileDeletedEvent) {
    val assetId =
        dslContext.fetchValue(MUX_ASSETS.ASSET_ID, MUX_ASSETS.FILE_ID.eq(event.fileId)) ?: return

    // Asynchronously delete the asset from Mux; we don't want the event listener to block if
    // Mux takes a long time to respond.
    jobScheduler.enqueue<MuxService> { deleteMuxAssetIfExists(assetId) }

    dslContext.deleteFrom(MUX_ASSETS).where(MUX_ASSETS.FILE_ID.eq(event.fileId)).execute()
  }

  @Suppress("MemberVisibilityCanBePrivate") // Called by JobRunr
  fun deleteMuxAssetIfExists(assetId: String) {
    try {
      sendRequest<Unit>("/video/v1/assets/$assetId")
    } catch (e: ClientRequestException) {
      // Ignore "not found" responses since this is a "delete if exists" operation.
      if (e.response.status != HttpStatusCode.NotFound) {
        throw e
      }
    }
  }

  /**
   * Parses a Mux-provided signing key. Mux's private keys are provided as base64-encoded strings
   * that decode to PEM-formatted RSA private keys.
   */
  private fun parseSigningKey(): PrivateKey {
    val pemString =
        Base64.getDecoder().decode(config.mux.signingKeyPrivate).toString(Charsets.US_ASCII)
    val pemObj = PEMParser(StringReader(pemString)).readObject() as PEMKeyPair
    val keySpec = PKCS8EncodedKeySpec(pemObj.privateKeyInfo.encoded)
    return KeyFactory.getInstance("RSA").generatePrivate(keySpec)
  }

  private suspend fun doSendRequest(
      path: String,
      body: Any? = null,
      httpMethod: HttpMethod,
  ): HttpResponse {
    val url = muxApiUrl.resolve(path).toString()

    return try {
      httpClient.request(url) {
        method = httpMethod
        basicAuth(tokenId, tokenSecret)
        body?.let { setBody(it) }
      }
    } catch (e: ClientRequestException) {
      log.debug("Mux response ${e.response.status}: ${e.response.bodyAsText()}")
      throw e
    }
  }

  private inline fun <reified T> sendRequest(
      path: String,
      body: Any? = null,
      method: HttpMethod = if (body != null) HttpMethod.Post else HttpMethod.Get,
  ): T {
    ensureEnabled()

    return runBlocking {
      val response = doSendRequest(path, body, method)
      if (T::class.java == Unit.javaClass) {
        T::class.objectInstance!!
      } else {
        response.body()
      }
    }
  }

  private fun ensureEnabled() {
    if (!config.mux.enabled) {
      throw IllegalStateException("Mux is not enabled")
    }
  }
}
