package com.terraformation.backend.file.mux

import MuxCreateVideoAssetRequestPayload
import MuxCreateVideoAssetResponsePayload
import com.terraformation.backend.config.TerrawareServerConfig
import com.terraformation.backend.db.default_schema.FileId
import com.terraformation.backend.db.default_schema.MuxAssetStatus
import com.terraformation.backend.db.default_schema.tables.references.MUX_ASSETS
import com.terraformation.backend.file.FileService
import com.terraformation.backend.file.VideoStreamNotFoundException
import com.terraformation.backend.log.perClassLogger
import io.jsonwebtoken.Jwts
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.plugins.ClientRequestException
import io.ktor.client.request.basicAuth
import io.ktor.client.request.request
import io.ktor.client.request.setBody
import io.ktor.client.statement.HttpResponse
import io.ktor.client.statement.bodyAsText
import io.ktor.http.HttpMethod
import jakarta.inject.Named
import java.io.StringReader
import java.net.URI
import java.security.KeyFactory
import java.security.PrivateKey
import java.security.spec.PKCS8EncodedKeySpec
import java.time.Duration
import java.time.InstantSource
import java.util.Base64
import java.util.Date
import kotlinx.coroutines.runBlocking
import org.bouncycastle.openssl.PEMKeyPair
import org.bouncycastle.openssl.PEMParser
import org.jooq.DSLContext

@Named
class MuxService(
    private val clock: InstantSource,
    private val config: TerrawareServerConfig,
    private val dslContext: DSLContext,
    private val fileService: FileService,
    private val httpClient: HttpClient,
) {
  /**
   * How long to make files available for Mux to download. The files will have random URLs but will
   * be accessible without authentication for this amount of time; it should be long enough to let
   * Mux retry if there's a transient error.
   */
  private val fileAccessTokenExpiration = Duration.ofHours(24)

  /**
   * URL path prefix of the "download a file without authentication" endpoint. The file access token
   * generated by [FileService] will be added as a path element beneath this path.
   */
  private val fileAccessEndpoint = "/api/v1/files/tokens"

  private val muxApiUrl = URI("https://api.mux.com")

  private val log = perClassLogger()

  // Non-null copies of config values.
  private lateinit var tokenId: String
  private lateinit var tokenSecret: String
  private lateinit var signingKey: PrivateKey
  private lateinit var signingKeyId: String
  private lateinit var baseUrl: URI

  init {
    if (config.mux.enabled) {
      baseUrl = config.mux.externalUrl ?: config.webAppUrl
      signingKey = parseSigningKey()
      signingKeyId = config.mux.signingKeyId!!
      tokenId = config.mux.tokenId!!
      tokenSecret = config.mux.tokenSecret!!
    }
  }

  /**
   * Sends a video file to Mux for processing. At a high level, the flow is
   * 1. Generate a file access token that's good for some amount of time. See
   *    [FileService.createToken].
   * 2. Tell Mux to download the original file from us using that token and to create a playback
   *    configuration that requires a signed playback token.
   * 3. Record the Mux IDs (asset, playback) from that request.
   * 4. After Mux is done processing the file, it sends us a webhook request to indicate the result.
   * 5. Record the file's status (ready or errored).
   */
  fun sendFileToMux(fileId: FileId): String {
    ensureEnabled()

    val token = fileService.createToken(fileId, fileAccessTokenExpiration)

    val request =
        MuxCreateVideoAssetRequestPayload(
            fileId = fileId,
            test = config.mux.useTestAssets,
            url = baseUrl.resolve("$fileAccessEndpoint/$token"),
        )
    val response = sendRequest<MuxCreateVideoAssetResponsePayload>("/video/v1/assets", request)

    if (response.data.status == MuxApiStatus.errored) {
      log.warn("File $fileId marked as errored at creation time: ${response.data.errorMessage}")
    }

    val playbackId = response.data.playbackId ?: throw IllegalStateException("No playback ID found")

    with(MUX_ASSETS) {
      dslContext
          .insertInto(MUX_ASSETS)
          .set(ASSET_ID, response.data.id)
          .set(CREATED_TIME, clock.instant())
          .set(ERROR_MESSAGE, response.data.errorMessage)
          .set(FILE_ID, fileId)
          .set(MUX_ASSET_STATUS_ID, response.data.status.assetStatus)
          .set(PLAYBACK_ID, playbackId)
          .execute()
    }

    return playbackId
  }

  /**
   * Returns information a client needs in order to configure a video player to stream a file from
   * Mux. For access control, this includes a time-limited playback token that expires.
   *
   * @param expiration How long the stream should be accessible. After this, clients will need to
   *   request a new playback token.
   */
  fun getMuxStream(
      fileId: FileId,
      expiration: Duration = Duration.ofSeconds(config.mux.streamExpirationSeconds),
  ): MuxStreamModel {
    ensureEnabled()

    val playbackId =
        dslContext.fetchValue(MUX_ASSETS.PLAYBACK_ID, MUX_ASSETS.FILE_ID.eq(fileId))
            ?: throw VideoStreamNotFoundException(fileId)
    val token =
        Jwts.builder()
            .subject(playbackId)
            .claim("kid", signingKeyId)
            .claim("aud", "v") // "v" = token is for video playback
            .expiration(Date(clock.instant().plus(expiration).toEpochMilli()))
            .signWith(signingKey)
            .compact()

    return MuxStreamModel(fileId = fileId, playbackId = playbackId, playbackToken = token)
  }

  fun markAssetReady(fileId: FileId) {
    with(MUX_ASSETS) {
      if (!dslContext.fetchExists(MUX_ASSETS, FILE_ID.eq(fileId))) {
        log.error("Got ready update for unknown file $fileId")
      } else {
        dslContext
            .update(MUX_ASSETS)
            .set(MUX_ASSET_STATUS_ID, MuxAssetStatus.Ready)
            .set(READY_TIME, clock.instant())
            .where(FILE_ID.eq(fileId))
            .and(READY_TIME.isNull)
            .execute()

        log.info("File $fileId marked as ready by Mux")
      }
    }
  }

  fun markAssetDeleted(fileId: FileId) {
    with(MUX_ASSETS) {
      if (dslContext.deleteFrom(MUX_ASSETS).where(FILE_ID.eq(fileId)).execute() == 0) {
        log.error("Got delete update for unknown file $fileId")
      } else {
        log.info("Asset for file $fileId deleted by Mux")
      }
    }
  }

  fun markAssetErrored(fileId: FileId, errorMessage: String?) {
    with(MUX_ASSETS) {
      if (!dslContext.fetchExists(MUX_ASSETS, FILE_ID.eq(fileId))) {
        log.error("Got error update for unknown file $fileId")
      } else {
        dslContext
            .update(MUX_ASSETS)
            .set(ERROR_MESSAGE, errorMessage)
            .set(MUX_ASSET_STATUS_ID, MuxAssetStatus.Errored)
            .where(FILE_ID.eq(fileId))
            .execute()

        log.warn("File $fileId marked as errored by Mux: $errorMessage")
      }
    }
  }

  /**
   * Parses a Mux-provided signing key. Mux's private keys are provided as base64-encoded strings
   * that decode to PEM-formatted RSA private keys.
   */
  private fun parseSigningKey(): PrivateKey {
    val pemString =
        Base64.getDecoder().decode(config.mux.signingKeyPrivate).toString(Charsets.US_ASCII)
    val pemObj = PEMParser(StringReader(pemString)).readObject() as PEMKeyPair
    val keySpec = PKCS8EncodedKeySpec(pemObj.privateKeyInfo.encoded)
    return KeyFactory.getInstance("RSA").generatePrivate(keySpec)
  }

  private suspend fun doSendRequest(
      path: String,
      body: Any? = null,
      httpMethod: HttpMethod,
  ): HttpResponse {
    val url = muxApiUrl.resolve(path).toString()

    return try {
      httpClient.request(url) {
        method = httpMethod
        basicAuth(tokenId, tokenSecret)
        body?.let { setBody(it) }
      }
    } catch (e: ClientRequestException) {
      log.debug("Mux response ${e.response.status}: ${e.response.bodyAsText()}")
      throw e
    }
  }

  private inline fun <reified T> sendRequest(
      path: String,
      body: Any? = null,
      method: HttpMethod = if (body != null) HttpMethod.Post else HttpMethod.Get,
  ): T {
    ensureEnabled()

    return runBlocking {
      val response = doSendRequest(path, body, method)
      if (T::class.java == Unit.javaClass) {
        T::class.objectInstance!!
      } else {
        response.body()
      }
    }
  }

  private fun ensureEnabled() {
    if (!config.mux.enabled) {
      throw IllegalStateException("Mux is not enabled")
    }
  }
}
