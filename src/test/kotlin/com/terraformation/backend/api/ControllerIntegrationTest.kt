package com.terraformation.backend.api

import com.terraformation.backend.RunsAsDatabaseUser
import com.terraformation.backend.RunsAsUser
import com.terraformation.backend.auth.CurrentUserHolder
import com.terraformation.backend.auth.currentUser
import com.terraformation.backend.customer.model.TerrawareUser
import com.terraformation.backend.db.DatabaseBackedTest
import jakarta.servlet.Filter
import jakarta.ws.rs.core.MediaType
import org.junit.jupiter.api.BeforeEach
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.oidcLogin
import org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers
import org.springframework.test.web.servlet.MockMvc
import org.springframework.test.web.servlet.ResultActionsDsl
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders
import org.springframework.test.web.servlet.setup.DefaultMockMvcBuilder
import org.springframework.test.web.servlet.setup.MockMvcBuilders
import org.springframework.web.context.WebApplicationContext

/**
 * Superclass for tests that exercise controllers and require the application to be fully available.
 */
@SpringBootTest
abstract class ControllerIntegrationTest :
    ControllerIntegrationTestUserSetup(), RunsAsDatabaseUser {
  override lateinit var user: TerrawareUser

  @Autowired private lateinit var context: WebApplicationContext

  protected val mockMvc: MockMvc by lazy { makeMockMvc() }

  protected fun makeMockMvc(): MockMvc =
      MockMvcBuilders.webAppContextSetup(context)
          .defaultRequest<DefaultMockMvcBuilder>(
              MockMvcRequestBuilders.get("")
                  .contentType(MediaType.APPLICATION_JSON)
                  .accept(MediaType.APPLICATION_JSON)
                  .apply { with(oidcLogin().idToken { it.subject(currentUser().authId) }) })
          .apply<DefaultMockMvcBuilder>(SecurityMockMvcConfigurers.springSecurity())
          .addFilter<DefaultMockMvcBuilder>(makeSetUserFilter())
          .build()

  /**
   * Returns a servlet filter that replaces [user] with the user object that was loaded from the
   * database as part of handling the request. This allows us to examine the state of that user and
   * assert things about it in the test code.
   *
   * This filter should be registered after the Spring Security filters so that Spring Security has
   * already loaded the user by the time this filter is invoked.
   */
  private fun makeSetUserFilter() = Filter { request, response, chain ->
    CurrentUserHolder.getCurrentUser()?.let { user = it }
    chain.doFilter(request, response)
  }

  /**
   * Asserts that a controller returns an HTTP 200 response with a JSON body that includes the
   * specified contents.
   *
   * @param strict If true, require the content of the response to exactly match [json]: keys that
   *   are present in the response but not in [json] are treated as assertion failures. By default,
   *   extra keys are ignored. Whitespace is ignored even if this is true.
   */
  protected fun ResultActionsDsl.andExpectJson(
      json: String,
      strict: Boolean = false
  ): ResultActionsDsl {
    return andExpect {
      content { json(json, strict) }
      status { isOk() }
    }
  }

  /**
   * Asserts that a controller returns an HTTP 200 response with a JSON body that includes the
   * specified contents. The expected JSON string is generated by a function and may be constructed
   * dynamically (e.g., if it needs to include dynamically-allocated ID values).
   *
   * @param strict If true, require the content of the response to exactly match the return value of
   *   [jsonFunc]: keys that are present in the response but not in the return value of [jsonFunc]
   *   are treated as assertion failures. By default, extra keys are ignored. Whitespace is ignored
   *   even if this is true.
   * @param jsonFunc Function that returns the expected JSON string.
   */
  protected fun ResultActionsDsl.andExpectJson(
      strict: Boolean = false,
      jsonFunc: () -> String,
  ): ResultActionsDsl {
    return andExpectJson(jsonFunc(), strict)
  }
}

/**
 * Inserts the default user into the database before each test method is run.
 *
 * This needs to happen in a superclass of [ControllerIntegrationTest], rather than in
 * [ControllerIntegrationTest] itself, because it needs to run before the setup code in
 * [RunsAsUser]. JUnit executes BeforeEach functions starting at the top of the test class's
 * inheritance hierarchy, so if this were in [ControllerIntegrationTest], the [RunsAsUser] setup
 * would happen first.
 */
abstract class ControllerIntegrationTestUserSetup : DatabaseBackedTest() {
  @BeforeEach
  fun insertDefaultUser() {
    val userId = insertUser()
    (this as RunsAsDatabaseUser).switchToUser(userId)
  }
}
