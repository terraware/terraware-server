# Seed Bank Server

This is a partial implementation of a possible REST API for the seed bank data model in Kotlin. It serves both as a starting point for an eventual real implementation and as a demonstration of what it'd look like to build the service in Kotlin.

## Quickstart (to try running it locally)

### Prerequisites

* Docker (used by the build process)
* Java version 11 or higher ([AdoptOpenJDK](https://adoptopenjdk.net/) is a convenient place to get it)
* PostgreSQL

### Initial setup

* Create a local database: `createdb seedbank`
* Pull the PostgreSQL Docker image so the build process can launch it: `docker pull postgres:12`

### Running the server

Mac/Linux: `./gradlew run`

Windows: `gradlew.bat run`

The server will listen on port 8080. As a demo, it will create an API client with an API key of `dummyKey`, which you can use to make API requests.

Fetch the API schema. (This doesn't require authentication.)

    curl http://localhost:8080/swagger/terraware-seed-bank-0.1-SNAPSHOT.yml

Fetch the details of a sample site.

    curl -H "Authorization: Basic $(echo -n user:dummyKey | base64)" http://localhost:8080/api/v1/site/1

### Running the tests

Mac/Linux: `./gradlew test`

Windows: `gradlew.bat test`

## Editing the code

By far the best Kotlin development environment is [IntelliJ IDEA](https://www.jetbrains.com/idea/). You can use other editors or IDEs (the build, as you've seen from the quickstart, doesn't depend on an IDE) but IntelliJ is what you want.

1. Run IntelliJ.
2. In the welcome dialog, click Open.
3. Navigate to this repo using the file selector dialog.
4. Select `build.gradle.kts`.
5. Click Open.
6. In the popup, click "Open as Project".
7. Dismiss the hints-and-tips popup (or read some hints and tips, if you like).
8. On the left of the window is a folder view. Click the triangle to the left of the project folder to expand it.
9. Keep expanding: `src`, `main`, `kotlin`, `com.terraformation.seedbank`.
10. Right-click on `Application`.
11. Select "Run 'Application'".

The code should build (if you've previously built it from the command line, it will reuse some of those build artifacts) and the server should launch, with its output in a pane at the bottom of the IntelliJ window.

Once you've launched the application once, it will appear in the drop-down menu of run configurations in the toolbar at the top of the IntelliJ window. You can select it there and click the Run (triangle) or Debug (beetle) button to the right of the drop-down menu. You can also launch it with keyboard shortcuts but that's beyond the scope of this quick intro.

## Notable things

The code itself is, at this point, still pretty small, but there are a few things it demonstrates.

* Micronaut framework: This is kind of analogous in function to Flask; it provides the scaffolding to serve HTTP requests. The controller classes such as [`SiteController`](src/main/kotlin/com/terraformation/seedbank/api/SiteController.kt) use Micronaut's API, mostly in the form of annotations on classes and methods. Micronaut also does dependency injection; you'll notice that some of the classes have constructor arguments but aren't explicitly instantiated anywhere.
* Gradle: The build process is defined in [`build.gradle.kts`](build.gradle.kts). It may look kind of complicated and it sort of is, since it's where a lot of the things in this list are glued together. But for the most part, if you're working on the code, the only thing you'll regularly touch is the list of dependencies; look for the `dependencies` section.
* Database migrations: Look in [`src/main/resources/db/migration`](src/main/resources/db/migration) to see some examples. This uses [Flyway](https://flywaydb.org/). The short version is that the system runs the SQL in a set of files, sorted by version number, and keeps track of which ones it has already applied. If new ones appear in later code releases, they're applied automatically. Flyway also has the ability to run migrations by calling application code rather than applying SQL, but that's not demonstrated here.
* Schema-first code generation: After you've built the code, look in `src/main/generated` to see a bunch of generated Kotlin source files. These are created by [jOOQ](https://jooq.org/) as part of the build process, and allows us to do type-safe query construction.
* Migrations + code generation: The build script is set up to run database migrations against a temporary database (which it launches on the fly in a Docker container, hence the requirement to have Docker installed) and then does the code generation based on the schema that results from playing all the migrations. So you can add a migration, hit the "build" button, and start writing code that uses the autogenerated classes even before you've run the migration on your actual database.
* API documentation: Machine-readable OpenAPI (Swagger) documentation is generated as part of the build process, based on static analysis of request handlers (controller classes). It can be supplemented using annotations; that's demonstrated a bit on a couple of the endpoints.
* Security: We're still nailing the requirements down here but this code demonstrates some simple role-based access control using annotations on methods and classes, and also some application-code-based authorization checks (does the client belong to the same organization as the device, etc.)
* Logging: Look at [`src/main/resources/logback.xml`](src/main/resources/logback.xml) to see what the logging configuration looks like. Of particular note is that the configuration can vary by environment; environments can be autodetected or explicitly named using environment variables or command-line arguments.
* Testing: The included test class shows how to mock out the database and check that endpoints return appropriate HTTP errors. There's more to build out here (we will probably want some database-backed tests, for example).
