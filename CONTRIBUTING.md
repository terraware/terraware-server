# Contributing to the project

TODO: General text about how to contribute

## Coding conventions

The code should be written in idiomatic Kotlin and should generally follow the guidelines in the official Kotlin [Coding Conventions](https://kotlinlang.org/docs/reference/coding-conventions.html) document.

It runs on the JVM, and thus makes extensive use of Java libraries. There are no plans to support multiplatform builds. If you find a Java library that does just what you need, use it rather than reinventing the wheel!

Currently, the build targets the Java 15 JVM. It will likely track new JVM releases since there are often garbage collection improvements that can be significant in memory-constrained environments.

### Formatting

All Kotlin code must be formatted with [ktfmt](https://github.com/facebookincubator/ktfmt). You can run ktfmt in a couple different ways:

* Install the [ktfmt IntelliJ plugin](https://plugins.jetbrains.com/plugin/14912-ktfmt) (recommended). This will cause IntelliJ's "Reformat Code" action to use ktfmt.
* Invoke it from the command line. The project's Gradle configuration has a task for that purpose. On Mac/Linux, run `./gradlew spotlessApply` and on Windows, run `gradlew.bat spotlessApply`.

There isn't currently a way to make IntelliJ's real-time formatting adhere strictly to ktfmt's formatting rules, but the supplied `.editorconfig` file is an approximation. IntelliJ should detect it and use it automatically.

### Database access

The code uses a schema-first, code-generation approach to its data model, as opposed to a code-first approach where the database gets created based on class structure. It uses the [jOOQ](https://jooq.org) library to generate code that provides a fluent, type-safe query building API as well as some basic ORM features.

To make changes to the data model, add migration scripts. See [src/main/resources/db/migration/README.md](src/main/resources/db/migration/README.md) for more details.

### Dependency injection

If you need to call methods in other classes and the other classes can be instantiated once and then reused, use dependency injection rather than explicitly instantiating them. This makes it easier to replace the dependencies with stubs when testing, and also makes the interaction between service classes more explicit in the code.

In general, strongly prefer constructor injection, that is, declaring your dependencies as constructor arguments. You should almost never need to use the `@Autowired` or `@Inject` annotations on a field.

### Testability and tests

Automated tests are important tools to allow the code to evolve safely, and they serve as documentation of the code's intended behavior. The project does not have a specific coverage target (since that often leads to low-quality, thoughtless tests) but in general, any nontrivial business logic should be well covered by tests, including failure cases.

Stub out dependencies when possible. The project uses the [MockK](https://mockk.io/) library which provides a convenient stubbing API. It also supports verifying method calls on mocks; try to only use verification when an interaction with another object is part of a function's documented behavior rather than an implementation detail. As a rule of thumb, verify write operations and callbacks but not read operations.

Use coverage analysis tools such as IntelliJ's built-in coverage analyzer to help find code paths your tests didn't exercise.

Assume libraries and frameworks work properly. Don't write tests to check whether, e.g., the `@Secured` annotation on a controller actually rejects unauthenticated users, or that jOOQ is generating valid SQL. The exception is if you've run into a library bug that requires a workaround; in that case it's appropriate to add a test case to verify that the bug is present, so that when the bug is fixed the test will fail and tell us we can remove the workaround.

Never perform database queries inline in the application code; add separate data-access classes. For simple CRUD operations, the autogenerated jOOQ DAO classes may suffice. This keeps business-logic tests fast because the data access can be stubbed out cleanly.

Keep data-access classes focused on data access. Don't be afraid to use SQL to do what it's good at, rather than treating the database as a dumb key/value store. For example, use a join rather than fetching a list of IDs and then separately fetching the records those IDs refer to. But avoid embedding actual business logic in SQL queries unless there's a clear benefit in performance or safety or clarity, because then you'll be forced to write database-backed tests for the logic and those tests are slower and more brittle. If you do write nontrivial SQL queries, cover them with tests.

### Payload classes

Use data classes to represent API request and response payloads whenever possible, rather than using generic `Map` objects. This will allow the build process to generate more useful API documentation.

Generally, these payload classes should live in the same file as the controller classes that implement the API endpoints. If a particular payload class is used by 3 or more controllers, though, it should be moved to a separate file (which may contain multiple such payload classes if they are related to each other).
